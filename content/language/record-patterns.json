{
  "id": 7,
  "slug": "record-patterns",
  "title": "Record patterns (destructuring)",
  "category": "language",
  "difficulty": "intermediate",
  "jdkVersion": "21",
  "oldLabel": "Java 8",
  "modernLabel": "Java 21+",
  "oldApproach": "Manual Access",
  "modernApproach": "Destructuring",
  "oldCode": "if (obj instanceof Point) {\n    Point p = (Point) obj;\n    int x = p.getX();\n    int y = p.getY();\n    System.out.println(x + y);\n}",
  "modernCode": "if (obj instanceof Point(int x, int y)) {\n    System.out.println(x + y);\n}",
  "summary": "Destructure records directly in patterns â€” extract fields in one step.",
  "explanation": "Record patterns let you decompose a record's components directly in instanceof and switch. Nested patterns are supported too, enabling deep matching without intermediate variables.",
  "whyModernWins": [
    {
      "icon": "ğŸ¯",
      "title": "Direct extraction",
      "desc": "Access record components without calling accessors manually."
    },
    {
      "icon": "ğŸª†",
      "title": "Nestable",
      "desc": "Patterns can nest â€” match inner records in a single expression."
    },
    {
      "icon": "ğŸ“",
      "title": "Compact code",
      "desc": "Five lines become two â€” less ceremony, same clarity."
    }
  ],
  "support": "Widely available since JDK 21 LTS (Sept 2023)",
  "prev": "language/sealed-classes",
  "next": "language/unnamed-variables",
  "related": [
    "language/diamond-operator",
    "language/records-for-data-classes",
    "language/unnamed-variables"
  ]
}
