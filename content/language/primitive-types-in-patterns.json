{
  "id": 16,
  "slug": "primitive-types-in-patterns",
  "title": "Primitive types in patterns",
  "category": "language",
  "difficulty": "advanced",
  "jdkVersion": "25",
  "oldLabel": "Java 8",
  "modernLabel": "Java 25 (Preview)",
  "oldApproach": "Manual Range Checks",
  "modernApproach": "Primitive Patterns",
  "oldCode": "String classify(int code) {\n    if (code >= 200 && code < 300)\n        return \"success\";\n    else if (code >= 400 && code < 500)\n        return \"client error\";\n    else\n        return \"other\";\n}",
  "modernCode": "String classify(int code) {\n    return switch (code) {\n        case int c when c >= 200\n            && c < 300 -> \"success\";\n        case int c when c >= 400\n            && c < 500 -> \"client error\";\n        default -> \"other\";\n    };\n}",
  "summary": "Pattern matching now works with primitive types, not just objects.",
  "explanation": "Java 25 extends pattern matching to primitive types. You can use int, long, double etc. in switch patterns with when guards, eliminating the need for boxing or manual range checks.",
  "whyModernWins": [
    {
      "icon": "ðŸ“¦",
      "title": "No boxing",
      "desc": "Match primitives directly â€” no Integer wrapper needed."
    },
    {
      "icon": "ðŸŽ¯",
      "title": "Pattern consistency",
      "desc": "Same pattern syntax for objects and primitives."
    },
    {
      "icon": "âš¡",
      "title": "Better performance",
      "desc": "Avoid autoboxing overhead in pattern matching."
    }
  ],
  "support": "Preview in JDK 25 (third preview, JEP 507). Requires --enable-preview.",
  "prev": "language/guarded-patterns",
  "next": "language/module-import-declarations",
  "related": [
    "language/type-inference-with-var",
    "language/text-blocks-for-multiline-strings",
    "language/switch-expressions"
  ]
}
