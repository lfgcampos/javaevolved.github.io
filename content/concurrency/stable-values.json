{
  "id": 49,
  "slug": "stable-values",
  "title": "Stable values",
  "category": "concurrency",
  "difficulty": "advanced",
  "jdkVersion": "25",
  "oldLabel": "Java 8",
  "modernLabel": "Java 25 (Preview)",
  "oldApproach": "Double-Checked Locking",
  "modernApproach": "StableValue",
  "oldCode": "private volatile Logger logger;\nLogger getLogger() {\n    if (logger == null) {\n        synchronized (this) {\n            if (logger == null)\n                logger = createLogger();\n        }\n    }\n    return logger;\n}",
  "modernCode": "private final StableValue<Logger> logger =\n    StableValue.of(this::createLogger);\n\nLogger getLogger() {\n    return logger.get();\n}",
  "summary": "Thread-safe lazy initialization without volatile or synchronized.",
  "explanation": "StableValue provides a lazily initialized, immutable value with built-in thread safety. No double-checked locking, no volatile fields, no synchronized blocks. The JVM can even optimize the read path after initialization.",
  "whyModernWins": [
    {
      "icon": "üßπ",
      "title": "Zero boilerplate",
      "desc": "No volatile, synchronized, or null checks."
    },
    {
      "icon": "‚ö°",
      "title": "JVM-optimized",
      "desc": "The JVM can fold the value after initialization."
    },
    {
      "icon": "üõ°Ô∏è",
      "title": "Guaranteed once",
      "desc": "The supplier runs exactly once, even under contention."
    }
  ],
  "support": "Preview in JDK 25 (JEP 502). Requires --enable-preview.",
  "prev": "concurrency/scoped-values",
  "next": "concurrency/completablefuture-chaining",
  "related": [
    "concurrency/virtual-threads",
    "concurrency/structured-concurrency",
    "concurrency/scoped-values"
  ]
}
