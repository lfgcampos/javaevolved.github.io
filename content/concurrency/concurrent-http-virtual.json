{
  "id": 54,
  "slug": "concurrent-http-virtual",
  "title": "Concurrent HTTP with virtual threads",
  "category": "concurrency",
  "difficulty": "intermediate",
  "jdkVersion": "21",
  "oldLabel": "Java 8",
  "modernLabel": "Java 21+",
  "oldApproach": "Thread Pool + URLConnection",
  "modernApproach": "Virtual Threads + HttpClient",
  "oldCode": "ExecutorService pool =\n    Executors.newFixedThreadPool(10);\nList<Future<String>> futures =\n    urls.stream()\n    .map(u -> pool.submit(\n        () -> fetchUrl(u)))\n    .toList();\n// manual shutdown, blocking get()",
  "modernCode": "try (var exec = Executors\n    .newVirtualThreadPerTaskExecutor()) {\n    var results = urls.stream()\n        .map(u -> exec.submit(\n            () -> client.send(req(u),\n                ofString()).body()))\n        .toList().stream()\n        .map(Future::join).toList();\n}",
  "summary": "Fetch many URLs concurrently with virtual threads and HttpClient.",
  "explanation": "Virtual threads make it practical to create a thread per HTTP request. Combined with HttpClient, this replaces complex async callback patterns with simple blocking code that scales.",
  "whyModernWins": [
    {
      "icon": "‚ôæÔ∏è",
      "title": "Thread per request",
      "desc": "No pool sizing ‚Äî one virtual thread per URL."
    },
    {
      "icon": "üìñ",
      "title": "Simple code",
      "desc": "Write straightforward blocking code."
    },
    {
      "icon": "‚ö°",
      "title": "High throughput",
      "desc": "Thousands of concurrent requests with minimal resources."
    }
  ],
  "support": "Widely available since JDK 21 LTS (Sept 2023)",
  "prev": "concurrency/process-api",
  "next": "concurrency/lock-free-lazy-init",
  "related": [
    "concurrency/structured-concurrency",
    "concurrency/stable-values",
    "concurrency/lock-free-lazy-init"
  ]
}
