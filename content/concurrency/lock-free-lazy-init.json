{
  "id": 55,
  "slug": "lock-free-lazy-init",
  "title": "Lock-free lazy initialization",
  "category": "concurrency",
  "difficulty": "advanced",
  "jdkVersion": "25",
  "oldLabel": "Java 8",
  "modernLabel": "Java 25 (Preview)",
  "oldApproach": "synchronized + volatile",
  "modernApproach": "StableValue",
  "oldCode": "class Config {\n    private static volatile Config inst;\n    static Config get() {\n        if (inst == null) {\n            synchronized (Config.class) {\n                if (inst == null)\n                    inst = load();\n            }\n        }\n        return inst;\n    }\n}",
  "modernCode": "class Config {\n    private static final\n        StableValue<Config> INST =\n            StableValue.of(Config::load);\n\n    static Config get() {\n        return INST.get();\n    }\n}",
  "summary": "Replace double-checked locking with StableValue for lazy singletons.",
  "explanation": "StableValue encapsulates the lazy initialization pattern with correct thread safety. The JVM can optimize the read path after initialization, potentially making it faster than volatile reads.",
  "whyModernWins": [
    {
      "icon": "ðŸ§¹",
      "title": "No boilerplate",
      "desc": "No volatile, synchronized, or double-null-check."
    },
    {
      "icon": "âš¡",
      "title": "Faster reads",
      "desc": "JVM can constant-fold after initialization."
    },
    {
      "icon": "âœ…",
      "title": "Provably correct",
      "desc": "No subtle ordering bugs â€” the JVM handles it."
    }
  ],
  "support": "Preview in JDK 25 (JEP 502, StableValue). Requires --enable-preview.",
  "prev": "concurrency/concurrent-http-virtual",
  "next": "io/http-client",
  "related": [
    "concurrency/virtual-threads",
    "concurrency/structured-concurrency",
    "concurrency/scoped-values"
  ]
}
