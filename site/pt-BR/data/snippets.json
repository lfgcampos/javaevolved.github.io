[ {
  "id" : 95,
  "slug" : "compact-canonical-constructor",
  "title" : "Compact canonical constructor",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "16",
  "oldLabel" : "Java 16",
  "modernLabel" : "Java 16+",
  "oldApproach" : "Explicit constructor validation",
  "modernApproach" : "Compact constructor",
  "oldCode" : "public record Person(String name,\n                     List<String> pets) {\n    // Full canonical constructor\n    public Person(String name,\n                  List<String> pets) {\n        Objects.requireNonNull(name);\n        this.name = name;\n        this.pets = List.copyOf(pets);\n    }\n}",
  "modernCode" : "public record Person(String name,\n                     List<String> pets) {\n    // Compact constructor\n    public Person {\n        Objects.requireNonNull(name);\n        pets = List.copyOf(pets);\n    }\n}",
  "summary" : "Validate and normalize record fields without repeating parameter lists.",
  "explanation" : "Records can declare a compact canonical constructor that omits the parameter list and field assignments. The compiler automatically assigns parameters to fields after your validation logic runs. This is ideal for precondition checks, defensive copies, and normalization.",
  "whyModernWins" : [ {
    "icon" : "‚úÇÔ∏è",
    "title" : "Less repetition",
    "desc" : "No need to repeat parameter list or assign each field manually."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Validation",
    "desc" : "Perfect for null checks, range validation, and defensive copies."
  }, {
    "icon" : "üìñ",
    "title" : "Clearer intent",
    "desc" : "Compact syntax emphasizes validation, not boilerplate."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 16 (March 2021)"
  },
  "docs" : [ ]
}, {
  "id" : 9,
  "slug" : "compact-source-files",
  "title" : "Compact source files",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25",
  "oldApproach" : "Main Class Ceremony",
  "modernApproach" : "void main()",
  "oldCode" : "public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\n            \"Hello, World!\");\n    }\n}",
  "modernCode" : "void main() {\n    IO.println(\"Hello, World!\");\n}",
  "summary" : "Write a complete program without class declaration or public static void main.",
  "explanation" : "Compact source files remove the ceremony of class declarations and the main method signature for simple programs. Combined with implicit import of java.io.IO, even println is available directly.",
  "whyModernWins" : [ {
    "icon" : "üöÄ",
    "title" : "Zero ceremony",
    "desc" : "No class, no public static void main, no String[] args."
  }, {
    "icon" : "üéì",
    "title" : "Beginner-friendly",
    "desc" : "New programmers can write useful code from line 1."
  }, {
    "icon" : "üìù",
    "title" : "Script-like",
    "desc" : "Perfect for quick prototypes, scripts, and examples."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Finalized in JDK 25 LTS (JEP 512, Sept 2025)."
  },
  "docs" : [ {
    "title" : "Simple Source Files and Instance Main Methods (JEP 495)",
    "href" : "https://openjdk.org/jeps/495"
  } ]
}, {
  "id" : 86,
  "slug" : "default-interface-methods",
  "title" : "Default interface methods",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "8",
  "oldLabel" : "Java 7",
  "modernLabel" : "Java 8+",
  "oldApproach" : "Abstract classes for shared behavior",
  "modernApproach" : "Default methods on interfaces",
  "oldCode" : "// Need abstract class to share behavior\npublic abstract class AbstractLogger {\n    public void log(String msg) {\n        System.out.println(\n            timestamp() + \": \" + msg);\n    }\n    abstract String timestamp();\n}\n\n// Single inheritance only\npublic class FileLogger\n    extends AbstractLogger { ... }",
  "modernCode" : "public interface Logger {\n    default void log(String msg) {\n        System.out.println(\n            timestamp() + \": \" + msg);\n    }\n    String timestamp();\n}\n\n// Multiple interfaces allowed\npublic class FileLogger\n    implements Logger, Closeable { ... }",
  "summary" : "Add method implementations directly in interfaces, enabling multiple inheritance of behavior.",
  "explanation" : "Before Java 8, sharing behavior across unrelated classes required abstract classes, which limited you to single inheritance. Default methods let interfaces provide method implementations, so classes can inherit behavior from multiple interfaces. This was essential for evolving the Collections API (e.g., List.forEach, Map.getOrDefault) without breaking existing implementations.",
  "whyModernWins" : [ {
    "icon" : "üîÄ",
    "title" : "Multiple inheritance",
    "desc" : "Classes can implement many interfaces with default methods, unlike single abstract class inheritance."
  }, {
    "icon" : "üì¶",
    "title" : "API evolution",
    "desc" : "Add new methods to interfaces without breaking existing implementations."
  }, {
    "icon" : "üß©",
    "title" : "Composable behavior",
    "desc" : "Mix and match capabilities from multiple interfaces freely."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 8 (March 2014)."
  },
  "docs" : [ {
    "title" : "Default Methods (Java Tutorial)",
    "href" : "https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html"
  } ]
}, {
  "id" : 12,
  "slug" : "diamond-operator",
  "title" : "Diamond with anonymous classes",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 7/8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Repeat Type Args",
  "modernApproach" : "Diamond <>",
  "oldCode" : "Map<String, List<String>> map =\n    new HashMap<String, List<String>>();\n// anonymous class: no diamond\nPredicate<String> p =\n    new Predicate<String>() {\n        public boolean test(String s) {..}\n    };",
  "modernCode" : "Map<String, List<String>> map =\n    new HashMap<>();\n// Java 9: diamond with anonymous classes\nPredicate<String> p =\n    new Predicate<>() {\n        public boolean test(String s) {..}\n    };",
  "summary" : "Diamond operator now works with anonymous classes too.",
  "explanation" : "Java 7 introduced <> but it didn't work with anonymous inner classes. Java 9 fixed this, so you never need to repeat type arguments on the right-hand side.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Consistent rules",
    "desc" : "Diamond works everywhere ‚Äî constructors and anonymous classes alike."
  }, {
    "icon" : "üßπ",
    "title" : "Less redundancy",
    "desc" : "Type arguments are stated once on the left, never repeated."
  }, {
    "icon" : "üîß",
    "title" : "DRY principle",
    "desc" : "The compiler already knows the type ‚Äî why write it twice?"
  } ],
  "support" : {
    "state" : "available",
    "description" : "Diamond with anonymous classes since JDK 9 (Sept 2017)."
  },
  "docs" : [ {
    "title" : "Diamond with Anonymous Classes (JEP 213)",
    "href" : "https://openjdk.org/jeps/213"
  } ]
}, {
  "id" : 18,
  "slug" : "exhaustive-switch",
  "title" : "Exhaustive switch without default",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Mandatory default",
  "modernApproach" : "Sealed Exhaustiveness",
  "oldCode" : "// Must add default even though\n// all cases are covered\ndouble area(Shape s) {\n    if (s instanceof Circle c)\n        return Math.PI * c.r() * c.r();\n    else if (s instanceof Rect r)\n        return r.w() * r.h();\n    else throw new IAE();\n}",
  "modernCode" : "// sealed Shape permits Circle, Rect\ndouble area(Shape s) {\n    return switch (s) {\n        case Circle c ->\n            Math.PI * c.r() * c.r();\n        case Rect r ->\n            r.w() * r.h();\n    }; // no default needed!\n}",
  "summary" : "Compiler verifies all sealed subtypes are covered ‚Äî no default needed.",
  "explanation" : "When switching over a sealed type, the compiler knows all possible subtypes and verifies every case is handled. If you add a new subtype, the compiler flags every switch that's now incomplete.",
  "whyModernWins" : [ {
    "icon" : "‚úÖ",
    "title" : "Compile-time safety",
    "desc" : "Add a new subtype and the compiler shows every place to update."
  }, {
    "icon" : "üö´",
    "title" : "No dead code",
    "desc" : "No unreachable default branch that masks bugs."
  }, {
    "icon" : "üìê",
    "title" : "Algebraic types",
    "desc" : "Sealed + records + exhaustive switch = proper ADTs in Java."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Pattern Matching for switch (JEP 441)",
    "href" : "https://openjdk.org/jeps/441"
  }, {
    "title" : "Sealed Classes (JEP 409)",
    "href" : "https://openjdk.org/jeps/409"
  } ]
}, {
  "id" : 10,
  "slug" : "flexible-constructor-bodies",
  "title" : "Flexible constructor bodies",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25+",
  "oldApproach" : "Validate After super()",
  "modernApproach" : "Code Before super()",
  "oldCode" : "class Square extends Shape {\n    Square(double side) {\n        super(side, side);\n        // can't validate BEFORE super!\n        if (side <= 0)\n            throw new IAE(\"bad\");\n    }\n}",
  "modernCode" : "class Square extends Shape {\n    Square(double side) {\n        if (side <= 0)\n            throw new IAE(\"bad\");\n        super(side, side);\n    }\n}",
  "summary" : "Validate and compute values before calling super() or this().",
  "explanation" : "Java 25 lifts the restriction that super() must be the first statement. You can now validate arguments, compute derived values, and set up state before delegating to the parent constructor.",
  "whyModernWins" : [ {
    "icon" : "üõ°Ô∏è",
    "title" : "Fail fast",
    "desc" : "Validate arguments before the superclass constructor runs."
  }, {
    "icon" : "üßÆ",
    "title" : "Compute first",
    "desc" : "Derive values and prepare data before calling super()."
  }, {
    "icon" : "üßπ",
    "title" : "No workarounds",
    "desc" : "No more static helper methods or factory patterns to work around the restriction."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Finalized in JDK 25 LTS (JEP 513, Sept 2025)."
  },
  "docs" : [ {
    "title" : "Flexible Constructor Bodies (JEP 492)",
    "href" : "https://openjdk.org/jeps/492"
  } ]
}, {
  "id" : 15,
  "slug" : "guarded-patterns",
  "title" : "Guarded patterns with when",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Nested if",
  "modernApproach" : "when Clause",
  "oldCode" : "if (shape instanceof Circle c) {\n    if (c.radius() > 10) {\n        return \"large circle\";\n    } else {\n        return \"small circle\";\n    }\n} else {\n    return \"not a circle\";\n}",
  "modernCode" : "return switch (shape) {\n    case Circle c\n        when c.radius() > 10\n            -> \"large circle\";\n    case Circle c\n            -> \"small circle\";\n    default -> \"not a circle\";\n};",
  "summary" : "Add conditions to pattern cases using when guards.",
  "explanation" : "Guarded patterns let you refine a type match with an additional boolean condition. This keeps all the branching logic in the switch instead of nesting if statements inside cases.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Precise matching",
    "desc" : "Combine type + condition in a single case label."
  }, {
    "icon" : "üìê",
    "title" : "Flat structure",
    "desc" : "No nested if/else inside switch cases."
  }, {
    "icon" : "üìñ",
    "title" : "Readable intent",
    "desc" : "The when clause reads like natural language."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Pattern Matching for switch (JEP 441)",
    "href" : "https://openjdk.org/jeps/441"
  } ]
}, {
  "id" : 92,
  "slug" : "markdown-javadoc-comments",
  "title" : "Markdown in Javadoc comments",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "23",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 23+",
  "oldApproach" : "HTML-based Javadoc",
  "modernApproach" : "Markdown Javadoc",
  "oldCode" : "/**\n * Returns the {@code User} with\n * the given ID.\n *\n * <p>Example:\n * <pre>{@code\n * var user = findUser(123);\n * }</pre>\n *\n * @param id the user ID\n * @return the user\n */\npublic User findUser(int id) { ... }",
  "modernCode" : "/// Returns the `User` with\n/// the given ID.\n///\n/// Example:\n/// ```java\n/// var user = findUser(123);\n/// ```\n///\n/// @param id the user ID\n/// @return the user\npublic User findUser(int id) { ... }",
  "summary" : "Write Javadoc comments in Markdown instead of HTML for better readability.",
  "explanation" : "Java 23 introduces /// Markdown-style Javadoc comments as an alternative to the traditional /** */ HTML-based format. Markdown syntax is more natural to write and read, with support for code blocks, emphasis, lists, and links. The compiler converts Markdown to HTML for javadoc output.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Natural syntax",
    "desc" : "Use backticks for inline code and ``` for blocks instead of HTML tags."
  }, {
    "icon" : "‚úçÔ∏è",
    "title" : "Easier to write",
    "desc" : "No need for {@code}, <pre>, <p> tags ‚Äî just write Markdown."
  }, {
    "icon" : "üëÅ",
    "title" : "Better in editors",
    "desc" : "Markdown renders beautifully in modern IDEs and text editors."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 23 (Sept 2024)"
  },
  "docs" : [ ]
}, {
  "id" : 17,
  "slug" : "module-import-declarations",
  "title" : "Module import declarations",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25+",
  "oldApproach" : "Many Imports",
  "modernApproach" : "import module",
  "oldCode" : "import java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;",
  "modernCode" : "import module java.base;\n\n// All of java.util, java.io, java.nio\n// etc. available in one line",
  "summary" : "Import all exported packages of a module with a single declaration.",
  "explanation" : "Module import declarations let you import everything a module exports with one line. This is especially useful for java.base which covers collections, I/O, streams, and more.",
  "whyModernWins" : [ {
    "icon" : "üßπ",
    "title" : "One line",
    "desc" : "Replace a wall of imports with a single module import."
  }, {
    "icon" : "üì¶",
    "title" : "Module-aware",
    "desc" : "Leverages the module system to import coherent sets of packages."
  }, {
    "icon" : "üöÄ",
    "title" : "Quick starts",
    "desc" : "Perfect for scripts and prototypes where import lists are tedious."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Finalized in JDK 25 LTS (JEP 511, Sept 2025)."
  },
  "docs" : [ {
    "title" : "Module Import Declarations (JEP 494)",
    "href" : "https://openjdk.org/jeps/494"
  } ]
}, {
  "id" : 4,
  "slug" : "pattern-matching-instanceof",
  "title" : "Pattern matching for instanceof",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "16",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 16+",
  "oldApproach" : "instanceof + Cast",
  "modernApproach" : "Pattern Variable",
  "oldCode" : "if (obj instanceof String) {\n    String s = (String) obj;\n    System.out.println(s.length());\n}",
  "modernCode" : "if (obj instanceof String s) {\n    System.out.println(s.length());\n}",
  "summary" : "Combine type check and cast in one step with pattern matching.",
  "explanation" : "Pattern matching for instanceof eliminates the redundant cast after a type check. The variable is automatically scoped to where the pattern matches, making code safer and shorter.",
  "whyModernWins" : [ {
    "icon" : "üîÑ",
    "title" : "No redundant cast",
    "desc" : "Type check and variable binding happen in a single expression."
  }, {
    "icon" : "üìè",
    "title" : "Fewer lines",
    "desc" : "One line instead of two ‚Äî the cast line disappears entirely."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Scope safety",
    "desc" : "The pattern variable is only in scope where the type is guaranteed."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 16 (March 2021)"
  },
  "docs" : [ {
    "title" : "Pattern Matching for instanceof (JEP 394)",
    "href" : "https://openjdk.org/jeps/394"
  } ]
}, {
  "id" : 14,
  "slug" : "pattern-matching-switch",
  "title" : "Pattern matching in switch",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "if-else Chain",
  "modernApproach" : "Type Patterns",
  "oldCode" : "String format(Object obj) {\n    if (obj instanceof Integer i)\n        return \"int: \" + i;\n    else if (obj instanceof Double d)\n        return \"double: \" + d;\n    else if (obj instanceof String s)\n        return \"str: \" + s;\n    return \"unknown\";\n}",
  "modernCode" : "String format(Object obj) {\n    return switch (obj) {\n        case Integer i -> \"int: \" + i;\n        case Double d  -> \"double: \" + d;\n        case String s  -> \"str: \" + s;\n        default        -> \"unknown\";\n    };\n}",
  "summary" : "Replace if-else instanceof chains with clean switch type patterns.",
  "explanation" : "Pattern matching in switch lets you match on types directly, combining the type test, cast, and binding in one concise case label. The compiler checks completeness.",
  "whyModernWins" : [ {
    "icon" : "üìê",
    "title" : "Structured dispatch",
    "desc" : "Switch makes the branching structure explicit and scannable."
  }, {
    "icon" : "üéØ",
    "title" : "Expression form",
    "desc" : "Returns a value directly ‚Äî no mutable variable needed."
  }, {
    "icon" : "‚úÖ",
    "title" : "Exhaustiveness",
    "desc" : "The compiler ensures all types are handled."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Pattern Matching for switch (JEP 441)",
    "href" : "https://openjdk.org/jeps/441"
  } ]
}, {
  "id" : 16,
  "slug" : "primitive-types-in-patterns",
  "title" : "Primitive types in patterns",
  "category" : "language",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25 (Preview)",
  "oldApproach" : "Manual Range Checks",
  "modernApproach" : "Primitive Patterns",
  "oldCode" : "String classify(int code) {\n    if (code >= 200 && code < 300)\n        return \"success\";\n    else if (code >= 400 && code < 500)\n        return \"client error\";\n    else\n        return \"other\";\n}",
  "modernCode" : "String classify(int code) {\n    return switch (code) {\n        case int c when c >= 200\n            && c < 300 -> \"success\";\n        case int c when c >= 400\n            && c < 500 -> \"client error\";\n        default -> \"other\";\n    };\n}",
  "summary" : "Pattern matching now works with primitive types, not just objects.",
  "explanation" : "Java 25 extends pattern matching to primitive types. You can use int, long, double etc. in switch patterns with when guards, eliminating the need for boxing or manual range checks.",
  "whyModernWins" : [ {
    "icon" : "üì¶",
    "title" : "No boxing",
    "desc" : "Match primitives directly ‚Äî no Integer wrapper needed."
  }, {
    "icon" : "üéØ",
    "title" : "Pattern consistency",
    "desc" : "Same pattern syntax for objects and primitives."
  }, {
    "icon" : "‚ö°",
    "title" : "Better performance",
    "desc" : "Avoid autoboxing overhead in pattern matching."
  } ],
  "support" : {
    "state" : "preview",
    "description" : "Preview in JDK 25 (third preview, JEP 507). Requires --enable-preview."
  },
  "docs" : [ {
    "title" : "Primitive Types in Patterns (JEP 488)",
    "href" : "https://openjdk.org/jeps/488"
  } ]
}, {
  "id" : 13,
  "slug" : "private-interface-methods",
  "title" : "Private interface methods",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Duplicated Logic",
  "modernApproach" : "Private Methods",
  "oldCode" : "interface Logger {\n    default void logInfo(String msg) {\n        System.out.println(\n            \"[INFO] \" + timestamp() + msg);\n    }\n    default void logWarn(String msg) {\n        System.out.println(\n            \"[WARN] \" + timestamp() + msg);\n    }\n}",
  "modernCode" : "interface Logger {\n    private String format(String lvl, String msg) {\n        return \"[\" + lvl + \"] \" + timestamp() + msg;\n    }\n    default void logInfo(String msg) {\n        System.out.println(format(\"INFO\", msg));\n    }\n    default void logWarn(String msg) {\n        System.out.println(format(\"WARN\", msg));\n    }\n}",
  "summary" : "Extract shared logic in interfaces using private methods.",
  "explanation" : "Java 9 allows private methods in interfaces, enabling you to share code between default methods without exposing implementation details to implementing classes.",
  "whyModernWins" : [ {
    "icon" : "üß©",
    "title" : "Code reuse",
    "desc" : "Share logic between default methods without duplication."
  }, {
    "icon" : "üîê",
    "title" : "Encapsulation",
    "desc" : "Implementation details stay hidden from implementing classes."
  }, {
    "icon" : "üßπ",
    "title" : "DRY interfaces",
    "desc" : "No more copy-paste between default methods."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Private Interface Methods",
    "href" : "https://openjdk.org/jeps/213"
  } ]
}, {
  "id" : 7,
  "slug" : "record-patterns",
  "title" : "Record patterns (destructuring)",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Manual Access",
  "modernApproach" : "Destructuring",
  "oldCode" : "if (obj instanceof Point) {\n    Point p = (Point) obj;\n    int x = p.getX();\n    int y = p.getY();\n    System.out.println(x + y);\n}",
  "modernCode" : "if (obj instanceof Point(int x, int y)) {\n    System.out.println(x + y);\n}",
  "summary" : "Destructure records directly in patterns ‚Äî extract fields in one step.",
  "explanation" : "Record patterns let you decompose a record's components directly in instanceof and switch. Nested patterns are supported too, enabling deep matching without intermediate variables.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Direct extraction",
    "desc" : "Access record components without calling accessors manually."
  }, {
    "icon" : "ü™Ü",
    "title" : "Nestable",
    "desc" : "Patterns can nest ‚Äî match inner records in a single expression."
  }, {
    "icon" : "üìè",
    "title" : "Compact code",
    "desc" : "Five lines become two ‚Äî less ceremony, same clarity."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Record Patterns (JEP 440)",
    "href" : "https://openjdk.org/jeps/440"
  } ]
}, {
  "id" : 5,
  "slug" : "records-for-data-classes",
  "title" : "Records para classes de dados",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "16",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 16+",
  "oldApproach" : "POJO verboso",
  "modernApproach" : "record",
  "oldCode" : "public class Point {\n    private final int x, y;\n    public Point(int x, int y) { ... }\n    public int getX() { return x; }\n    public int getY() { return y; }\n    // equals, hashCode, toString\n}",
  "modernCode" : "public record Point(int x, int y) {}",
  "summary" : "Uma linha substitui mais de 30 linhas de boilerplate para portadores de dados imut√°veis.",
  "explanation" : "Records geram automaticamente o construtor, acessores (x(), y()), equals(), hashCode() e toString(). S√£o imut√°veis por design e ideais para DTOs, objetos de valor e pattern matching.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Defini√ß√£o em uma linha",
    "desc" : "Uma √∫nica linha substitui construtor, getters, equals, hashCode, toString."
  }, {
    "icon" : "üîí",
    "title" : "Imut√°vel por padr√£o",
    "desc" : "Todos os campos s√£o final ‚Äî sem armadilhas de setters."
  }, {
    "icon" : "üß©",
    "title" : "Compat√≠vel com patterns",
    "desc" : "Records funcionam com padr√µes de desestrutura√ß√£o em switch e instanceof."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Amplamente dispon√≠vel desde o JDK 16 (mar√ßo de 2021)"
  },
  "docs" : [ {
    "title" : "Records (JEP 395)",
    "href" : "https://openjdk.org/jeps/395"
  }, {
    "title" : "Record class",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Record.html"
  } ]
}, {
  "id" : 6,
  "slug" : "sealed-classes",
  "title" : "Sealed classes for type hierarchies",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "17",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 17+",
  "oldApproach" : "Open Hierarchy",
  "modernApproach" : "sealed permits",
  "oldCode" : "// Anyone can extend Shape\npublic abstract class Shape { }\npublic class Circle extends Shape { }\npublic class Rect extends Shape { }\n// unknown subclasses possible",
  "modernCode" : "public sealed interface Shape\n    permits Circle, Rect {}\npublic record Circle(double r)\n    implements Shape {}\npublic record Rect(double w, double h)\n    implements Shape {}",
  "summary" : "Restrict which classes can extend a type ‚Äî enabling exhaustive switches.",
  "explanation" : "Sealed classes define a closed set of subtypes. The compiler knows all possible cases, enabling exhaustive pattern matching without a default branch. Combined with records, they model algebraic data types.",
  "whyModernWins" : [ {
    "icon" : "üîê",
    "title" : "Controlled hierarchy",
    "desc" : "Only permitted subtypes can extend ‚Äî no surprise subclasses."
  }, {
    "icon" : "‚úÖ",
    "title" : "Exhaustive matching",
    "desc" : "The compiler verifies switch covers all cases, no default needed."
  }, {
    "icon" : "üìê",
    "title" : "Algebraic data types",
    "desc" : "Model sum types naturally ‚Äî sealed + records = ADTs in Java."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 17 LTS (Sept 2021)"
  },
  "docs" : [ {
    "title" : "Sealed Classes (JEP 409)",
    "href" : "https://openjdk.org/jeps/409"
  } ]
}, {
  "id" : 94,
  "slug" : "static-members-in-inner-classes",
  "title" : "Static members in inner classes",
  "category" : "language",
  "difficulty" : "intermediate",
  "jdkVersion" : "16",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 16+",
  "oldApproach" : "Must use static nested class",
  "modernApproach" : "Static members in inner classes",
  "oldCode" : "class Library {\n    // Must be static nested class\n    static class Book {\n        static int globalBookCount;\n\n        Book() {\n            globalBookCount++;\n        }\n    }\n}\n\n// Usage\nvar book = new Library.Book();",
  "modernCode" : "class Library {\n    // Can be inner class with statics\n    class Book {\n        static int globalBookCount;\n\n        Book() {\n            Book.globalBookCount++;\n        }\n    }\n}\n\n// Usage\nvar lib = new Library();\nvar book = lib.new Book();",
  "summary" : "Define static members in inner classes without requiring static nested classes.",
  "explanation" : "Before Java 16, only static nested classes could contain static members. Inner (non-static) classes couldn't have statics because they required an enclosing instance. Java 16 relaxes this restriction, allowing static fields, methods, and even nested types in inner classes.",
  "whyModernWins" : [ {
    "icon" : "üîì",
    "title" : "More flexibility",
    "desc" : "Inner classes can now have static members when needed."
  }, {
    "icon" : "üß©",
    "title" : "Shared state",
    "desc" : "Track shared state across instances of an inner class."
  }, {
    "icon" : "üìê",
    "title" : "Design freedom",
    "desc" : "No need to promote to static nested class just for one static field."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 16 (March 2021)"
  },
  "docs" : [ ]
}, {
  "id" : 93,
  "slug" : "static-methods-in-interfaces",
  "title" : "Static methods in interfaces",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "8",
  "oldLabel" : "Java 7",
  "modernLabel" : "Java 8+",
  "oldApproach" : "Utility classes",
  "modernApproach" : "Interface static methods",
  "oldCode" : "// Separate utility class needed\npublic class ValidatorUtils {\n    public static boolean isBlank(\n        String s) {\n        return s == null ||\n               s.trim().isEmpty();\n    }\n}\n\n// Usage\nif (ValidatorUtils.isBlank(input)) { ... }",
  "modernCode" : "public interface Validator {\n    boolean validate(String s);\n\n    static boolean isBlank(String s) {\n        return s == null ||\n               s.trim().isEmpty();\n    }\n}\n\n// Usage\nif (Validator.isBlank(input)) { ... }",
  "summary" : "Add static utility methods directly to interfaces instead of separate utility classes.",
  "explanation" : "Before Java 8, utility methods related to an interface had to live in a separate class (e.g., Collections for Collection). Static methods in interfaces let you keep related utilities together. Common in modern APIs like Comparator.comparing(), Stream.of(), and List.of().",
  "whyModernWins" : [ {
    "icon" : "üì¶",
    "title" : "Better organization",
    "desc" : "Keep related utilities with the interface, not in a separate class."
  }, {
    "icon" : "üîç",
    "title" : "Discoverability",
    "desc" : "Factory and helper methods are found where you'd expect them."
  }, {
    "icon" : "üß©",
    "title" : "API cohesion",
    "desc" : "No need for separate *Utils or *Helper classes."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 8 (March 2014)"
  },
  "docs" : [ ]
}, {
  "id" : 3,
  "slug" : "switch-expressions",
  "title" : "Switch expressions",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "14",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 14+",
  "oldApproach" : "Switch Statement",
  "modernApproach" : "Switch Expression",
  "oldCode" : "String msg;\nswitch (day) {\n    case MONDAY:\n        msg = \"Start\";\n        break;\n    case FRIDAY:\n        msg = \"End\";\n        break;\n    default:\n        msg = \"Mid\";\n}",
  "modernCode" : "String msg = switch (day) {\n    case MONDAY  -> \"Start\";\n    case FRIDAY  -> \"End\";\n    default      -> \"Mid\";\n};",
  "summary" : "Switch as an expression that returns a value ‚Äî no break, no fall-through.",
  "explanation" : "Switch expressions return a value directly, use arrow syntax to prevent fall-through bugs, and the compiler verifies exhaustiveness. This replaces the error-prone statement form.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Returns a value",
    "desc" : "Assign the switch result directly ‚Äî no temporary variable needed."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "No fall-through",
    "desc" : "Arrow syntax eliminates accidental fall-through bugs from missing break."
  }, {
    "icon" : "‚úÖ",
    "title" : "Exhaustiveness check",
    "desc" : "The compiler ensures all cases are covered."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 14 (March 2020)"
  },
  "docs" : [ {
    "title" : "Switch Expressions (JEP 361)",
    "href" : "https://openjdk.org/jeps/361"
  } ]
}, {
  "id" : 2,
  "slug" : "text-blocks-for-multiline-strings",
  "title" : "Text blocks for multiline strings",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "15",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 15+",
  "oldApproach" : "String Concatenation",
  "modernApproach" : "Text Blocks",
  "oldCode" : "String json = \"{\\n\" +\n    \"  \\\"name\\\": \\\"Duke\\\",\\n\" +\n    \"  \\\"age\\\": 30\\n\" +\n    \"}\";",
  "modernCode" : "String json = \"\"\"\n    {\n      \"name\": \"Duke\",\n      \"age\": 30\n    }\"\"\";",
  "summary" : "Write multiline strings naturally with triple-quote text blocks.",
  "explanation" : "Text blocks let you write multiline strings exactly as they appear. No more escaping quotes or adding \\n. The compiler strips incidental indentation automatically.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Readable as-is",
    "desc" : "JSON, SQL, and HTML look like real JSON, SQL, and HTML in your source."
  }, {
    "icon" : "üö´",
    "title" : "No escape hell",
    "desc" : "Embedded quotes don't need backslash escaping."
  }, {
    "icon" : "üìê",
    "title" : "Smart indentation",
    "desc" : "Leading whitespace is trimmed automatically based on the closing delimiter position."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 15 (Sept 2020)"
  },
  "docs" : [ {
    "title" : "Text Blocks (JEP 378)",
    "href" : "https://openjdk.org/jeps/378"
  }, {
    "title" : "Text Blocks Guide",
    "href" : "https://docs.oracle.com/en/java/javase/25/language/text-blocks.html"
  } ]
}, {
  "id" : 1,
  "slug" : "type-inference-with-var",
  "title" : "Infer√™ncia de tipo com var",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "10",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 10+",
  "oldApproach" : "Tipos expl√≠citos",
  "modernApproach" : "Palavra-chave var",
  "oldCode" : "Map<String, List<Integer>> map =\n    new HashMap<String, List<Integer>>();\nfor (Map.Entry<String, List<Integer>> e\n    : map.entrySet()) {\n    // verbose type noise\n}",
  "modernCode" : "var map = new HashMap<String, List<Integer>>();\nfor (var entry : map.entrySet()) {\n    // clean and readable\n}",
  "summary" : "Use var para infer√™ncia de tipo em vari√°veis locais ‚Äî menos ru√≠do, mesma seguran√ßa.",
  "explanation" : "Desde o Java 10, o compilador infere os tipos de vari√°veis locais a partir do lado direito da atribui√ß√£o. Isso reduz o ru√≠do visual sem sacrificar a seguran√ßa de tipos. Use var quando o tipo for √≥bvio pelo contexto.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Menos boilerplate",
    "desc" : "N√£o √© necess√°rio repetir tipos gen√©ricos complexos em ambos os lados da atribui√ß√£o."
  }, {
    "icon" : "üëÅ",
    "title" : "Melhor legibilidade",
    "desc" : "Foco nos nomes de vari√°veis e valores, n√£o nas declara√ß√µes de tipo."
  }, {
    "icon" : "üîí",
    "title" : "Ainda seguro em tipos",
    "desc" : "O compilador infere e imp√µe o tipo exato em tempo de compila√ß√£o."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Amplamente dispon√≠vel desde o JDK 10 (mar√ßo de 2018)"
  },
  "docs" : [ {
    "title" : "Local Variable Type Inference (JEP 286)",
    "href" : "https://openjdk.org/jeps/286"
  }, {
    "title" : "Style Guidelines for var",
    "href" : "https://openjdk.org/projects/amber/guides/lvti-style-guide"
  } ]
}, {
  "id" : 8,
  "slug" : "unnamed-variables",
  "title" : "Unnamed variables with _",
  "category" : "language",
  "difficulty" : "beginner",
  "jdkVersion" : "22",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 22+",
  "oldApproach" : "Unused Variable",
  "modernApproach" : "_ Placeholder",
  "oldCode" : "try {\n    parse(input);\n} catch (Exception ignored) {\n    log(\"parse failed\");\n}\nmap.forEach((key, value) -> {\n    process(value); // key unused\n});",
  "modernCode" : "try {\n    parse(input);\n} catch (Exception _) {\n    log(\"parse failed\");\n}\nmap.forEach((_, value) -> {\n    process(value);\n});",
  "summary" : "Use _ to signal intent when a variable is intentionally unused.",
  "explanation" : "Unnamed variables communicate to readers and tools that a value is deliberately ignored. No more 'ignored' or 'unused' naming conventions, no more IDE warnings.",
  "whyModernWins" : [ {
    "icon" : "üì¢",
    "title" : "Clear intent",
    "desc" : "_ explicitly says 'this value is not needed here'."
  }, {
    "icon" : "üîá",
    "title" : "No warnings",
    "desc" : "IDEs and linters won't flag intentionally unused variables."
  }, {
    "icon" : "üßπ",
    "title" : "Cleaner lambdas",
    "desc" : "Multi-param lambdas are cleaner when you only need some params."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Finalized in JDK 22 (JEP 456, March 2024)."
  },
  "docs" : [ {
    "title" : "Unnamed Variables & Patterns (JEP 456)",
    "href" : "https://openjdk.org/jeps/456"
  } ]
}, {
  "id" : 26,
  "slug" : "collectors-teeing",
  "title" : "Collectors.teeing()",
  "category" : "collections",
  "difficulty" : "intermediate",
  "jdkVersion" : "12",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 12+",
  "oldApproach" : "Two Passes",
  "modernApproach" : "teeing()",
  "oldCode" : "long count = items.stream().count();\ndouble sum = items.stream()\n    .mapToDouble(Item::price)\n    .sum();\nvar result = new Stats(count, sum);",
  "modernCode" : "var result = items.stream().collect(\n    Collectors.teeing(\n        Collectors.counting(),\n        Collectors.summingDouble(Item::price),\n        Stats::new\n    )\n);",
  "summary" : "Compute two aggregations in a single stream pass.",
  "explanation" : "Collectors.teeing() sends each element to two downstream collectors and merges the results. This avoids streaming the data twice or using a mutable accumulator.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Single pass",
    "desc" : "Process the stream once instead of twice."
  }, {
    "icon" : "üß©",
    "title" : "Composable",
    "desc" : "Combine any two collectors with a merger function."
  }, {
    "icon" : "üîí",
    "title" : "Immutable result",
    "desc" : "Merge into a record or value object directly."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 12 (March 2019)"
  },
  "docs" : [ {
    "title" : "Collectors.teeing()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Collectors.html#teeing(java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction)"
  } ]
}, {
  "id" : 22,
  "slug" : "copying-collections-immutably",
  "title" : "Copying collections immutably",
  "category" : "collections",
  "difficulty" : "beginner",
  "jdkVersion" : "10",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 10+",
  "oldApproach" : "Manual Copy + Wrap",
  "modernApproach" : "List.copyOf()",
  "oldCode" : "List<String> copy =\n    Collections.unmodifiableList(\n        new ArrayList<>(original)\n    );",
  "modernCode" : "List<String> copy =\n    List.copyOf(original);",
  "summary" : "Create an immutable copy of any collection in one call.",
  "explanation" : "List.copyOf(), Set.copyOf(), and Map.copyOf() create immutable snapshots of existing collections. If the source is already an immutable collection, no copy is made.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Smart copy",
    "desc" : "Skips the copy if the source is already immutable."
  }, {
    "icon" : "üìè",
    "title" : "One call",
    "desc" : "No manual ArrayList construction + wrapping."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Defensive copy",
    "desc" : "Changes to the original don't affect the copy."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 10 (March 2018)"
  },
  "docs" : [ {
    "title" : "List.copyOf()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/List.html#copyOf(java.util.Collection)"
  } ]
}, {
  "id" : 19,
  "slug" : "immutable-list-creation",
  "title" : "Cria√ß√£o de listas imut√°veis",
  "category" : "collections",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Encapsulamento verboso",
  "modernApproach" : "List.of()",
  "oldCode" : "List<String> list =\n    Collections.unmodifiableList(\n        new ArrayList<>(\n            Arrays.asList(\"a\", \"b\", \"c\")\n        )\n    );",
  "modernCode" : "List<String> list =\n    List.of(\"a\", \"b\", \"c\");",
  "summary" : "Crie listas imut√°veis em uma express√£o limpa.",
  "explanation" : "List.of() cria uma lista verdadeiramente imut√°vel ‚Äî sem encapsulamento, sem c√≥pia defensiva. Rejeita elementos nulos (null-hostile) e √© estruturalmente imut√°vel. O modo antigo exigia tr√™s chamadas aninhadas.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Uma chamada",
    "desc" : "Substitua tr√™s chamadas aninhadas por um √∫nico m√©todo f√°brica."
  }, {
    "icon" : "üîí",
    "title" : "Verdadeiramente imut√°vel",
    "desc" : "N√£o √© apenas um wrapper ‚Äî a lista em si √© imut√°vel."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Seguro contra nulos",
    "desc" : "Rejeita elementos nulos no momento da cria√ß√£o, falhando rapidamente."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Amplamente dispon√≠vel desde o JDK 9 (setembro de 2017)"
  },
  "docs" : [ {
    "title" : "List.of()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/List.html#of()"
  }, {
    "title" : "Collections Factory Methods (JEP 269)",
    "href" : "https://openjdk.org/jeps/269"
  } ]
}, {
  "id" : 20,
  "slug" : "immutable-map-creation",
  "title" : "Immutable map creation",
  "category" : "collections",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Map Builder Pattern",
  "modernApproach" : "Map.of()",
  "oldCode" : "Map<String, Integer> map = new HashMap<>();\nmap.put(\"a\", 1);\nmap.put(\"b\", 2);\nmap.put(\"c\", 3);\nmap = Collections.unmodifiableMap(map);",
  "modernCode" : "Map<String, Integer> map =\n    Map.of(\"a\", 1, \"b\", 2, \"c\", 3);",
  "summary" : "Create immutable maps inline without a builder.",
  "explanation" : "Map.of() accepts key-value pairs inline and returns an immutable map. For more than 10 entries, use Map.ofEntries() with Map.entry() pairs.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Inline creation",
    "desc" : "No temporary mutable map needed."
  }, {
    "icon" : "üîí",
    "title" : "Immutable result",
    "desc" : "The map cannot be modified after creation."
  }, {
    "icon" : "üö´",
    "title" : "No null keys/values",
    "desc" : "Null entries are rejected immediately."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Map.of()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Map.html#of()"
  }, {
    "title" : "Map.ofEntries()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Map.html#ofEntries(java.util.Map.Entry...)"
  } ]
}, {
  "id" : 21,
  "slug" : "immutable-set-creation",
  "title" : "Immutable set creation",
  "category" : "collections",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Verbose Wrapping",
  "modernApproach" : "Set.of()",
  "oldCode" : "Set<String> set =\n    Collections.unmodifiableSet(\n        new HashSet<>(\n            Arrays.asList(\"a\", \"b\", \"c\")\n        )\n    );",
  "modernCode" : "Set<String> set =\n    Set.of(\"a\", \"b\", \"c\");",
  "summary" : "Create immutable sets with a single factory call.",
  "explanation" : "Set.of() creates a truly immutable set that rejects nulls and duplicate elements at creation time. No more wrapping mutable sets.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Concise",
    "desc" : "One line instead of three nested calls."
  }, {
    "icon" : "üö´",
    "title" : "Detects duplicates",
    "desc" : "Throws if you accidentally pass duplicate elements."
  }, {
    "icon" : "üîí",
    "title" : "Immutable",
    "desc" : "No add/remove possible after creation."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Set.of()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Set.html#of()"
  }, {
    "title" : "Collections Factory Methods (JEP 269)",
    "href" : "https://openjdk.org/jeps/269"
  } ]
}, {
  "id" : 23,
  "slug" : "map-entry-factory",
  "title" : "Map.entry() factory",
  "category" : "collections",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "SimpleEntry",
  "modernApproach" : "Map.entry()",
  "oldCode" : "Map.Entry<String, Integer> e =\n    new AbstractMap.SimpleEntry<>(\n        \"key\", 42\n    );",
  "modernCode" : "var e = Map.entry(\"key\", 42);",
  "summary" : "Create map entries with a clean factory method.",
  "explanation" : "Map.entry() replaces the verbose AbstractMap.SimpleEntry constructor. It returns an immutable entry, making it ideal for Map.ofEntries() and stream operations.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Concise",
    "desc" : "One line instead of three with a clearer intent."
  }, {
    "icon" : "üîí",
    "title" : "Immutable",
    "desc" : "The returned entry cannot be modified."
  }, {
    "icon" : "üß©",
    "title" : "Composable",
    "desc" : "Works perfectly with Map.ofEntries() for large maps."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Map.entry()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Map.html#entry(K,V)"
  } ]
}, {
  "id" : 96,
  "slug" : "reverse-list-iteration",
  "title" : "Reverse list iteration",
  "category" : "collections",
  "difficulty" : "beginner",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Manual ListIterator",
  "modernApproach" : "reversed()",
  "oldCode" : "for (ListIterator<String> it =\n        list.listIterator(list.size());\n    it.hasPrevious(); ) {\n    String element = it.previous();\n    System.out.println(element);\n}",
  "modernCode" : "for (String element : list.reversed()) {\n    System.out.println(element);\n}",
  "summary" : "Iterate over a list in reverse order with a clean for-each loop.",
  "explanation" : "The reversed() method from SequencedCollection returns a reverse-ordered view of the list. This view is backed by the original list, so no copying occurs. The enhanced for loop syntax makes reverse iteration as readable as forward iteration.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Natural syntax",
    "desc" : "Enhanced for loop instead of verbose ListIterator."
  }, {
    "icon" : "‚ö°",
    "title" : "No copying",
    "desc" : "reversed() returns a view ‚Äî no performance overhead."
  }, {
    "icon" : "üß©",
    "title" : "Consistent API",
    "desc" : "Works on List, Deque, SortedSet uniformly."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ ]
}, {
  "id" : 24,
  "slug" : "sequenced-collections",
  "title" : "Sequenced collections",
  "category" : "collections",
  "difficulty" : "beginner",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Index Arithmetic",
  "modernApproach" : "getFirst/getLast",
  "oldCode" : "// Get last element\nvar last = list.get(list.size() - 1);\n// Get first\nvar first = list.get(0);\n// Reverse iteration: manual",
  "modernCode" : "var last = list.getLast();\nvar first = list.getFirst();\nvar reversed = list.reversed();",
  "summary" : "Access first/last elements and reverse views with clean API methods.",
  "explanation" : "SequencedCollection adds getFirst(), getLast(), reversed(), addFirst(), addLast() to List, Deque, SortedSet, and LinkedHashSet. No more size-1 arithmetic or manual reverse iteration.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Self-documenting",
    "desc" : "getLast() is clearer than get(size()-1)."
  }, {
    "icon" : "üîÑ",
    "title" : "Reversed view",
    "desc" : "reversed() gives a view ‚Äî no copying needed."
  }, {
    "icon" : "üß©",
    "title" : "Uniform API",
    "desc" : "Works the same on List, Deque, SortedSet."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Sequenced Collections (JEP 431)",
    "href" : "https://openjdk.org/jeps/431"
  }, {
    "title" : "SequencedCollection",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/SequencedCollection.html"
  } ]
}, {
  "id" : 27,
  "slug" : "stream-toarray-typed",
  "title" : "Typed stream toArray",
  "category" : "collections",
  "difficulty" : "beginner",
  "jdkVersion" : "8",
  "oldLabel" : "Pre-Streams",
  "modernLabel" : "Java 8+",
  "oldApproach" : "Manual Array Copy",
  "modernApproach" : "toArray(generator)",
  "oldCode" : "List<String> list = getNames();\nString[] arr = new String[list.size()];\nfor (int i = 0; i < list.size(); i++) {\n    arr[i] = list.get(i);\n}",
  "modernCode" : "String[] arr = getNames().stream()\n    .filter(n -> n.length() > 3)\n    .toArray(String[]::new);",
  "summary" : "Convert streams to typed arrays with a method reference.",
  "explanation" : "The toArray(IntFunction) method creates a properly typed array from a stream. The generator (String[]::new) tells the stream what type of array to create.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Type-safe",
    "desc" : "No Object[] cast ‚Äî the array type is correct."
  }, {
    "icon" : "üîó",
    "title" : "Chainable",
    "desc" : "Works at the end of any stream pipeline."
  }, {
    "icon" : "üìè",
    "title" : "Concise",
    "desc" : "One expression replaces the manual loop."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 8 (March 2014)"
  },
  "docs" : [ {
    "title" : "Stream.toArray()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#toArray(java.util.function.IntFunction)"
  } ]
}, {
  "id" : 28,
  "slug" : "unmodifiable-collectors",
  "title" : "Unmodifiable collectors",
  "category" : "collections",
  "difficulty" : "intermediate",
  "jdkVersion" : "16",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 16+",
  "oldApproach" : "collectingAndThen",
  "modernApproach" : "stream.toList()",
  "oldCode" : "List<String> list = stream.collect(\n    Collectors.collectingAndThen(\n        Collectors.toList(),\n        Collections::unmodifiableList\n    )\n);",
  "modernCode" : "List<String> list = stream.toList();",
  "summary" : "Collect directly to an unmodifiable list with stream.toList().",
  "explanation" : "Java 10 added toUnmodifiableList(), toUnmodifiableSet(), and toUnmodifiableMap() to replace the verbose collectingAndThen wrapper. For lists specifically, Java 16's stream.toList() provides an even simpler alternative ‚Äî no collect() call at all. Use toUnmodifiableSet() and toUnmodifiableMap() for other collection types.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Shortest yet",
    "desc" : "stream.toList() needs no collect() or Collectors import at all."
  }, {
    "icon" : "üîí",
    "title" : "Immutable",
    "desc" : "Result cannot be modified ‚Äî no accidental mutations."
  }, {
    "icon" : "üìñ",
    "title" : "Readable",
    "desc" : "Reads naturally as the terminal step of any stream pipeline."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 16 (March 2021)"
  },
  "docs" : [ {
    "title" : "Stream.toList()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#toList()"
  }, {
    "title" : "Collectors.toUnmodifiableList()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Collectors.html#toUnmodifiableList()"
  } ]
}, {
  "id" : 35,
  "slug" : "string-chars-stream",
  "title" : "String chars as stream",
  "category" : "strings",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Manual Loop",
  "modernApproach" : "chars() Stream",
  "oldCode" : "for (int i = 0; i < str.length(); i++) {\n    char c = str.charAt(i);\n    if (Character.isDigit(c)) {\n        process(c);\n    }\n}",
  "modernCode" : "str.chars()\n    .filter(Character::isDigit)\n    .forEach(c -> process((char) c));",
  "summary" : "Process string characters as a stream pipeline.",
  "explanation" : "String.chars() returns an IntStream of character values, enabling functional processing. For Unicode support, codePoints() handles supplementary characters correctly.",
  "whyModernWins" : [ {
    "icon" : "üîó",
    "title" : "Chainable",
    "desc" : "Use filter, map, collect on character streams."
  }, {
    "icon" : "üìê",
    "title" : "Declarative",
    "desc" : "Describe what to do, not how to loop."
  }, {
    "icon" : "üåê",
    "title" : "Unicode-ready",
    "desc" : "codePoints() correctly handles emoji and supplementary chars."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 8+ (improved in 9+)"
  },
  "docs" : [ {
    "title" : "String.chars()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#chars()"
  }, {
    "title" : "CharSequence.codePoints()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/CharSequence.html#codePoints()"
  } ]
}, {
  "id" : 33,
  "slug" : "string-formatted",
  "title" : "String.formatted()",
  "category" : "strings",
  "difficulty" : "beginner",
  "jdkVersion" : "15",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 15+",
  "oldApproach" : "String.format()",
  "modernApproach" : "formatted()",
  "oldCode" : "String msg = String.format(\n    \"Hello %s, you are %d\",\n    name, age\n);",
  "modernCode" : "String msg =\n    \"Hello %s, you are %d\"\n    .formatted(name, age);",
  "summary" : "Call formatted() on the template string itself.",
  "explanation" : "String.formatted() is an instance method equivalent to String.format() but called on the format string. It reads more naturally in a left-to-right flow.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Reads naturally",
    "desc" : "Template.formatted(args) flows better than String.format(template, args)."
  }, {
    "icon" : "üîó",
    "title" : "Chainable",
    "desc" : "Can be chained with other string methods."
  }, {
    "icon" : "üìè",
    "title" : "Less verbose",
    "desc" : "Drops the redundant String.format() static call."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 15 (Sept 2020)"
  },
  "docs" : [ {
    "title" : "String.formatted()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#formatted(java.lang.Object...)"
  } ]
}, {
  "id" : 32,
  "slug" : "string-indent-transform",
  "title" : "String.indent() and transform()",
  "category" : "strings",
  "difficulty" : "beginner",
  "jdkVersion" : "12",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 12+",
  "oldApproach" : "Manual Indentation",
  "modernApproach" : "indent() / transform()",
  "oldCode" : "String[] lines = text.split(\"\\n\");\nStringBuilder sb = new StringBuilder();\nfor (String line : lines) {\n    sb.append(\"    \").append(line)\n      .append(\"\\n\");\n}\nString indented = sb.toString();",
  "modernCode" : "String indented = text.indent(4);\n\nString result = text\n    .transform(String::strip)\n    .transform(s -> s.replace(\" \", \"-\"));",
  "summary" : "Indent text and chain string transformations fluently.",
  "explanation" : "indent(n) adds n spaces to each line. transform(fn) applies any function and returns the result, enabling fluent chaining of string operations.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Built-in",
    "desc" : "Indentation is a common operation ‚Äî now it's one call."
  }, {
    "icon" : "üîó",
    "title" : "Chainable",
    "desc" : "transform() enables fluent pipelines on strings."
  }, {
    "icon" : "üßπ",
    "title" : "Clean code",
    "desc" : "No manual line splitting and StringBuilder loops."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 12 (March 2019)"
  },
  "docs" : [ {
    "title" : "String.indent()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#indent(int)"
  }, {
    "title" : "String.transform()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#transform(java.util.function.Function)"
  } ]
}, {
  "id" : 29,
  "slug" : "string-isblank",
  "title" : "String.isBlank()",
  "category" : "strings",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "trim().isEmpty()",
  "modernApproach" : "isBlank()",
  "oldCode" : "boolean blank =\n    str.trim().isEmpty();\n// or: str.trim().length() == 0",
  "modernCode" : "boolean blank = str.isBlank();\n// handles Unicode whitespace too",
  "summary" : "Check for blank strings with a single method call.",
  "explanation" : "isBlank() returns true if the string is empty or contains only whitespace, including Unicode whitespace characters that trim() misses.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Self-documenting",
    "desc" : "isBlank() says exactly what it checks."
  }, {
    "icon" : "üåê",
    "title" : "Unicode-aware",
    "desc" : "Handles all Unicode whitespace, not just ASCII."
  }, {
    "icon" : "‚ö°",
    "title" : "No allocation",
    "desc" : "No intermediate trimmed string is created."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "String.isBlank()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#isBlank()"
  } ]
}, {
  "id" : 86,
  "slug" : "string-lines",
  "title" : "String.lines() for line splitting",
  "category" : "strings",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "split(\"\\\\n\")",
  "modernApproach" : "lines()",
  "oldCode" : "String text = \"one\\ntwo\\nthree\";\nString[] lines = text.split(\"\\n\");\nfor (String line : lines) {\n    System.out.println(line);\n}",
  "modernCode" : "String text = \"one\\ntwo\\nthree\";\ntext.lines().forEach(System.out::println);",
  "summary" : "Use String.lines() to split text into a stream of lines without regex overhead.",
  "explanation" : "String.lines() returns a Stream<String> of lines split by \\n, \\r, or \\r\\n. It is lazier and more efficient than split(), avoids regex compilation, and integrates naturally with the Stream API for further processing.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Lazy streaming",
    "desc" : "Lines are produced on demand, not all at once like split()."
  }, {
    "icon" : "üîß",
    "title" : "Universal line endings",
    "desc" : "Handles \\n, \\r, and \\r\\n automatically without regex."
  }, {
    "icon" : "üîó",
    "title" : "Stream integration",
    "desc" : "Returns a Stream for direct use with filter, map, collect."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 11 (September 2018)."
  },
  "docs" : [ {
    "title" : "String.lines()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#lines()"
  } ]
}, {
  "id" : 31,
  "slug" : "string-repeat",
  "title" : "String.repeat()",
  "category" : "strings",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "StringBuilder Loop",
  "modernApproach" : "repeat()",
  "oldCode" : "StringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 3; i++) {\n    sb.append(\"abc\");\n}\nString result = sb.toString();",
  "modernCode" : "String result = \"abc\".repeat(3);\n// \"abcabcabc\"",
  "summary" : "Repeat a string n times without a loop.",
  "explanation" : "String.repeat(int) returns the string concatenated with itself n times. Handles edge cases: repeat(0) returns empty string, repeat(1) returns the same string.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "One-liner",
    "desc" : "Replace 5 lines of StringBuilder code with one call."
  }, {
    "icon" : "‚ö°",
    "title" : "Optimized",
    "desc" : "Internal implementation is optimized for large repeats."
  }, {
    "icon" : "üìñ",
    "title" : "Clear intent",
    "desc" : "repeat(3) immediately conveys the purpose."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "String.repeat()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#repeat(int)"
  } ]
}, {
  "id" : 30,
  "slug" : "string-strip",
  "title" : "String.strip() vs trim()",
  "category" : "strings",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "trim()",
  "modernApproach" : "strip()",
  "oldCode" : "// trim() only removes ASCII whitespace\n// (chars <= U+0020)\nString clean = str.trim();",
  "modernCode" : "// strip() removes all Unicode whitespace\nString clean = str.strip();\nString left  = str.stripLeading();\nString right = str.stripTrailing();",
  "summary" : "Use Unicode-aware stripping with strip(), stripLeading(), stripTrailing().",
  "explanation" : "trim() only removes characters ‚â§ U+0020 (ASCII control chars and space). strip() uses Character.isWhitespace() which handles Unicode spaces like non-breaking space, ideographic space, etc.",
  "whyModernWins" : [ {
    "icon" : "üåê",
    "title" : "Unicode-correct",
    "desc" : "Handles all whitespace characters from every script."
  }, {
    "icon" : "üéØ",
    "title" : "Directional",
    "desc" : "stripLeading() and stripTrailing() for one-sided trimming."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Fewer bugs",
    "desc" : "No surprise whitespace left behind in international text."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "String.strip()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#strip()"
  } ]
}, {
  "id" : 39,
  "slug" : "collectors-flatmapping",
  "title" : "Collectors.flatMapping()",
  "category" : "streams",
  "difficulty" : "intermediate",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Nested flatMap",
  "modernApproach" : "flatMapping()",
  "oldCode" : "// Flatten within a grouping collector\n// Required complex custom collector\nMap<String, Set<String>> tagsByDept =\n    // no clean way in Java 8",
  "modernCode" : "var tagsByDept = employees.stream()\n    .collect(groupingBy(\n        Emp::dept,\n        flatMapping(\n            e -> e.tags().stream(),\n            toSet()\n        )\n    ));",
  "summary" : "Use flatMapping() to flatten inside a grouping collector.",
  "explanation" : "Collectors.flatMapping() applies a one-to-many mapping as a downstream collector. It's the collector equivalent of Stream.flatMap() ‚Äî useful inside groupingBy or partitioningBy.",
  "whyModernWins" : [ {
    "icon" : "üß©",
    "title" : "Composable",
    "desc" : "Works as a downstream collector inside groupingBy."
  }, {
    "icon" : "üìê",
    "title" : "One pass",
    "desc" : "Flatten and group in a single stream traversal."
  }, {
    "icon" : "üîó",
    "title" : "Nestable",
    "desc" : "Combine with other downstream collectors."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Collectors.flatMapping()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Collectors.html#flatMapping(java.util.function.Function,java.util.stream.Collector)"
  } ]
}, {
  "id" : 44,
  "slug" : "optional-ifpresentorelse",
  "title" : "Optional.ifPresentOrElse()",
  "category" : "streams",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "if/else on Optional",
  "modernApproach" : "ifPresentOrElse()",
  "oldCode" : "Optional<User> user = findUser(id);\nif (user.isPresent()) {\n    greet(user.get());\n} else {\n    handleMissing();\n}",
  "modernCode" : "findUser(id).ifPresentOrElse(\n    this::greet,\n    this::handleMissing\n);",
  "summary" : "Handle both present and empty cases of Optional in one call.",
  "explanation" : "ifPresentOrElse() takes a Consumer for the present case and a Runnable for the empty case. It avoids the isPresent/get anti-pattern.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Single expression",
    "desc" : "Both cases handled in one method call."
  }, {
    "icon" : "üö´",
    "title" : "No get()",
    "desc" : "Eliminates the dangerous isPresent() + get() pattern."
  }, {
    "icon" : "üîó",
    "title" : "Fluent",
    "desc" : "Chains naturally after findUser() or any Optional-returning method."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Optional.ifPresentOrElse()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Optional.html#ifPresentOrElse(java.util.function.Consumer,java.lang.Runnable)"
  } ]
}, {
  "id" : 45,
  "slug" : "optional-or",
  "title" : "Optional.or() fallback",
  "category" : "streams",
  "difficulty" : "intermediate",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Nested Fallback",
  "modernApproach" : ".or() chain",
  "oldCode" : "Optional<Config> cfg = primary();\nif (!cfg.isPresent()) {\n    cfg = secondary();\n}\nif (!cfg.isPresent()) {\n    cfg = defaults();\n}",
  "modernCode" : "Optional<Config> cfg = primary()\n    .or(this::secondary)\n    .or(this::defaults);",
  "summary" : "Chain Optional fallbacks without nested checks.",
  "explanation" : "Optional.or() returns the original Optional if it has a value, otherwise evaluates the supplier to get an alternative Optional. Suppliers are lazy ‚Äî only called when needed.",
  "whyModernWins" : [ {
    "icon" : "üîó",
    "title" : "Chainable",
    "desc" : "Stack fallbacks in a readable pipeline."
  }, {
    "icon" : "‚ö°",
    "title" : "Lazy evaluation",
    "desc" : "Fallback suppliers only execute if needed."
  }, {
    "icon" : "üìñ",
    "title" : "Declarative",
    "desc" : "Reads as 'try primary, or secondary, or defaults'."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Optional.or()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Optional.html#or(java.util.function.Supplier)"
  } ]
}, {
  "id" : 87,
  "slug" : "predicate-not",
  "title" : "Predicate.not() for negation",
  "category" : "streams",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "Lambda negation",
  "modernApproach" : "Predicate.not()",
  "oldCode" : "List<String> nonEmpty = list.stream()\n    .filter(s -> !s.isBlank())\n    .collect(Collectors.toList());",
  "modernCode" : "List<String> nonEmpty = list.stream()\n    .filter(Predicate.not(String::isBlank))\n    .toList();",
  "summary" : "Use Predicate.not() to negate method references cleanly instead of writing lambda wrappers.",
  "explanation" : "Before Java 11, negating a method reference required wrapping it in a lambda. Predicate.not() lets you negate any predicate directly, keeping the code readable and consistent with method reference style throughout the stream pipeline.",
  "whyModernWins" : [ {
    "icon" : "üëÅ",
    "title" : "Cleaner negation",
    "desc" : "No need to wrap method references in lambdas just to negate them."
  }, {
    "icon" : "üîó",
    "title" : "Composable",
    "desc" : "Works with any Predicate, enabling clean predicate chains."
  }, {
    "icon" : "üìñ",
    "title" : "Reads naturally",
    "desc" : "Predicate.not(String::isBlank) reads like English."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 11 (September 2018)."
  },
  "docs" : [ {
    "title" : "Predicate.not()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/function/Predicate.html#not(java.util.function.Predicate)"
  } ]
}, {
  "id" : 42,
  "slug" : "stream-gatherers",
  "title" : "Stream gatherers",
  "category" : "streams",
  "difficulty" : "advanced",
  "jdkVersion" : "24",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 24+",
  "oldApproach" : "Custom Collector",
  "modernApproach" : "gather()",
  "oldCode" : "// Sliding window: manual implementation\nList<List<T>> windows = new ArrayList<>();\nfor (int i = 0; i <= list.size()-3; i++) {\n    windows.add(\n        list.subList(i, i + 3));\n}",
  "modernCode" : "var windows = stream\n    .gather(\n        Gatherers.windowSliding(3)\n    )\n    .toList();",
  "summary" : "Use gatherers for custom intermediate stream operations.",
  "explanation" : "Gatherers are a new intermediate stream operation that can express complex transformations like sliding windows, fixed-size groups, and scan operations that were impossible with standard stream ops.",
  "whyModernWins" : [ {
    "icon" : "üß©",
    "title" : "Composable",
    "desc" : "Gatherers compose with other stream operations."
  }, {
    "icon" : "üì¶",
    "title" : "Built-in operations",
    "desc" : "windowFixed, windowSliding, fold, scan out of the box."
  }, {
    "icon" : "üîß",
    "title" : "Extensible",
    "desc" : "Write custom gatherers for any intermediate transformation."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Finalized in JDK 24 (JEP 485, March 2025)."
  },
  "docs" : [ {
    "title" : "Stream Gatherers (JEP 485)",
    "href" : "https://openjdk.org/jeps/485"
  }, {
    "title" : "Gatherers",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Gatherers.html"
  } ]
}, {
  "id" : 37,
  "slug" : "stream-iterate-predicate",
  "title" : "Stream.iterate() with predicate",
  "category" : "streams",
  "difficulty" : "intermediate",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "iterate + limit",
  "modernApproach" : "iterate(seed, pred, op)",
  "oldCode" : "Stream.iterate(1, n -> n * 2)\n    .limit(10)\n    .forEach(System.out::println);\n// can't stop at a condition",
  "modernCode" : "Stream.iterate(\n    1,\n    n -> n < 1000,\n    n -> n * 2\n).forEach(System.out::println);\n// stops when n >= 1000",
  "summary" : "Use a predicate to stop iteration ‚Äî like a for-loop in stream form.",
  "explanation" : "The three-argument Stream.iterate(seed, hasNext, next) works like a for-loop: seed is the start, hasNext determines when to stop, and next produces the next value.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Natural termination",
    "desc" : "Stop based on a condition, not an arbitrary limit."
  }, {
    "icon" : "üìê",
    "title" : "For-loop equivalent",
    "desc" : "Same semantics as for(seed; hasNext; next)."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "No infinite stream risk",
    "desc" : "The predicate guarantees termination."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Stream.iterate()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#iterate(T,java.util.function.Predicate,java.util.function.UnaryOperator)"
  } ]
}, {
  "id" : 41,
  "slug" : "stream-mapmulti",
  "title" : "Stream.mapMulti()",
  "category" : "streams",
  "difficulty" : "intermediate",
  "jdkVersion" : "16",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 16+",
  "oldApproach" : "flatMap + List",
  "modernApproach" : "mapMulti()",
  "oldCode" : "stream.flatMap(order ->\n    order.items().stream()\n        .map(item -> new OrderItem(\n            order.id(), item)\n        )\n);",
  "modernCode" : "stream.<OrderItem>mapMulti(\n    (order, downstream) -> {\n        for (var item : order.items())\n            downstream.accept(\n                new OrderItem(order.id(), item));\n    }\n);",
  "summary" : "Emit zero or more elements per input without creating intermediate streams.",
  "explanation" : "mapMulti() is an imperative alternative to flatMap that avoids creating intermediate Stream objects for each element. It's more efficient when the mapping produces a small number of elements.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Less allocation",
    "desc" : "No intermediate Stream created per element."
  }, {
    "icon" : "üéØ",
    "title" : "Imperative style",
    "desc" : "Use loops and conditionals directly."
  }, {
    "icon" : "üìê",
    "title" : "Flexible",
    "desc" : "Emit zero, one, or many elements with full control."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 16 (March 2021)"
  },
  "docs" : [ {
    "title" : "Stream.mapMulti()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#mapMulti(java.util.function.BiConsumer)"
  } ]
}, {
  "id" : 36,
  "slug" : "stream-of-nullable",
  "title" : "Stream.ofNullable()",
  "category" : "streams",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Null Check",
  "modernApproach" : "ofNullable()",
  "oldCode" : "Stream<String> s = val != null\n    ? Stream.of(val)\n    : Stream.empty();",
  "modernCode" : "Stream<String> s =\n    Stream.ofNullable(val);",
  "summary" : "Create a zero-or-one element stream from a nullable value.",
  "explanation" : "Stream.ofNullable() returns a single-element stream if the value is non-null, or an empty stream if null. Eliminates the ternary null check pattern.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Concise",
    "desc" : "One call replaces the ternary conditional."
  }, {
    "icon" : "üîó",
    "title" : "Flatmap-friendly",
    "desc" : "Perfect inside flatMap to skip null values."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Null-safe",
    "desc" : "No NPE risk ‚Äî null becomes empty stream."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Stream.ofNullable()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#ofNullable(T)"
  } ]
}, {
  "id" : 38,
  "slug" : "stream-takewhile-dropwhile",
  "title" : "Stream takeWhile / dropWhile",
  "category" : "streams",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Manual Loop",
  "modernApproach" : "takeWhile/dropWhile",
  "oldCode" : "List<Integer> result = new ArrayList<>();\nfor (int n : sorted) {\n    if (n >= 100) break;\n    result.add(n);\n}\n// no stream equivalent in Java 8",
  "modernCode" : "var result = sorted.stream()\n    .takeWhile(n -> n < 100)\n    .toList();\n// or: .dropWhile(n -> n < 10)",
  "summary" : "Take or drop elements from a stream based on a predicate.",
  "explanation" : "takeWhile() returns elements while the predicate is true and stops at the first false. dropWhile() skips elements while true and returns the rest. Both work best on ordered streams.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Short-circuit",
    "desc" : "Stops processing as soon as the predicate fails."
  }, {
    "icon" : "üîó",
    "title" : "Pipeline-friendly",
    "desc" : "Chain with other stream operations naturally."
  }, {
    "icon" : "üìñ",
    "title" : "Declarative",
    "desc" : "takeWhile reads like English: 'take while less than 100'."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Stream.takeWhile()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#takeWhile(java.util.function.Predicate)"
  }, {
    "title" : "Stream.dropWhile()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#dropWhile(java.util.function.Predicate)"
  } ]
}, {
  "id" : 40,
  "slug" : "stream-tolist",
  "title" : "Stream.toList()",
  "category" : "streams",
  "difficulty" : "beginner",
  "jdkVersion" : "16",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 16+",
  "oldApproach" : "Collectors.toList()",
  "modernApproach" : ".toList()",
  "oldCode" : "List<String> result = stream\n    .filter(s -> s.length() > 3)\n    .collect(Collectors.toList());",
  "modernCode" : "List<String> result = stream\n    .filter(s -> s.length() > 3)\n    .toList();",
  "summary" : "Terminal toList() replaces the verbose collect(Collectors.toList()).",
  "explanation" : "Stream.toList() returns an unmodifiable list. It's equivalent to .collect(Collectors.toUnmodifiableList()) but much shorter. Note: the result is immutable, unlike Collectors.toList().",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "7 chars vs 24",
    "desc" : ".toList() replaces .collect(Collectors.toList())."
  }, {
    "icon" : "üîí",
    "title" : "Immutable",
    "desc" : "The result list cannot be modified."
  }, {
    "icon" : "üìñ",
    "title" : "Fluent",
    "desc" : "Reads naturally at the end of a pipeline."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 16 (March 2021)"
  },
  "docs" : [ {
    "title" : "Stream.toList()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#toList()"
  } ]
}, {
  "id" : 43,
  "slug" : "virtual-thread-executor",
  "title" : "Virtual thread executor",
  "category" : "streams",
  "difficulty" : "intermediate",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Fixed Thread Pool",
  "modernApproach" : "Virtual Thread Executor",
  "oldCode" : "ExecutorService exec =\n    Executors.newFixedThreadPool(10);\ntry {\n    futures = tasks.stream()\n        .map(t -> exec.submit(t))\n        .toList();\n} finally {\n    exec.shutdown();\n}",
  "modernCode" : "try (var exec = Executors\n        .newVirtualThreadPerTaskExecutor()) {\n    var futures = tasks.stream()\n        .map(exec::submit)\n        .toList();\n}",
  "summary" : "Use virtual thread executors for unlimited lightweight concurrency.",
  "explanation" : "The virtual thread executor creates a new virtual thread for each task. No pool sizing needed ‚Äî virtual threads are cheap enough to create millions of them.",
  "whyModernWins" : [ {
    "icon" : "‚ôæÔ∏è",
    "title" : "No sizing",
    "desc" : "No pool size to tune ‚Äî create as many threads as needed."
  }, {
    "icon" : "‚ö°",
    "title" : "Lightweight",
    "desc" : "Virtual threads use KB of memory, not MB."
  }, {
    "icon" : "üßπ",
    "title" : "Auto-closeable",
    "desc" : "try-with-resources handles shutdown automatically."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Executors.newVirtualThreadPerTaskExecutor()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/Executors.html#newVirtualThreadPerTaskExecutor()"
  }, {
    "title" : "Virtual Threads (JEP 444)",
    "href" : "https://openjdk.org/jeps/444"
  } ]
}, {
  "id" : 50,
  "slug" : "completablefuture-chaining",
  "title" : "CompletableFuture chaining",
  "category" : "concurrency",
  "difficulty" : "intermediate",
  "jdkVersion" : "8",
  "oldLabel" : "Pre-Java 8",
  "modernLabel" : "Java 8+",
  "oldApproach" : "Blocking Future.get()",
  "modernApproach" : "CompletableFuture",
  "oldCode" : "Future<String> future =\n    executor.submit(this::fetchData);\nString data = future.get(); // blocks\nString result = transform(data);",
  "modernCode" : "CompletableFuture.supplyAsync(\n    this::fetchData\n)\n.thenApply(this::transform)\n.thenAccept(System.out::println);",
  "summary" : "Chain async operations without blocking, using CompletableFuture.",
  "explanation" : "CompletableFuture enables non-blocking async pipelines. Chain operations with thenApply, thenCompose, thenAccept. Handle errors with exceptionally(). Combine multiple futures with allOf/anyOf.",
  "whyModernWins" : [ {
    "icon" : "üîó",
    "title" : "Chainable",
    "desc" : "Compose async steps into a readable pipeline."
  }, {
    "icon" : "üö´",
    "title" : "Non-blocking",
    "desc" : "No thread sits idle waiting for results."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Error handling",
    "desc" : "exceptionally() and handle() for clean error recovery."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 8 (March 2014)"
  },
  "docs" : [ {
    "title" : "CompletableFuture",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/CompletableFuture.html"
  } ]
}, {
  "id" : 54,
  "slug" : "concurrent-http-virtual",
  "title" : "Concurrent HTTP with virtual threads",
  "category" : "concurrency",
  "difficulty" : "intermediate",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Thread Pool + URLConnection",
  "modernApproach" : "Virtual Threads + HttpClient",
  "oldCode" : "ExecutorService pool =\n    Executors.newFixedThreadPool(10);\nList<Future<String>> futures =\n    urls.stream()\n    .map(u -> pool.submit(\n        () -> fetchUrl(u)))\n    .toList();\n// manual shutdown, blocking get()",
  "modernCode" : "try (var exec = Executors\n    .newVirtualThreadPerTaskExecutor()) {\n    var results = urls.stream()\n        .map(u -> exec.submit(\n            () -> client.send(req(u),\n                ofString()).body()))\n        .toList().stream()\n        .map(Future::join).toList();\n}",
  "summary" : "Fetch many URLs concurrently with virtual threads and HttpClient.",
  "explanation" : "Virtual threads make it practical to create a thread per HTTP request. Combined with HttpClient, this replaces complex async callback patterns with simple blocking code that scales.",
  "whyModernWins" : [ {
    "icon" : "‚ôæÔ∏è",
    "title" : "Thread per request",
    "desc" : "No pool sizing ‚Äî one virtual thread per URL."
  }, {
    "icon" : "üìñ",
    "title" : "Simple code",
    "desc" : "Write straightforward blocking code."
  }, {
    "icon" : "‚ö°",
    "title" : "High throughput",
    "desc" : "Thousands of concurrent requests with minimal resources."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Virtual Threads (JEP 444)",
    "href" : "https://openjdk.org/jeps/444"
  }, {
    "title" : "HttpClient",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpClient.html"
  } ]
}, {
  "id" : 51,
  "slug" : "executor-try-with-resources",
  "title" : "ExecutorService auto-close",
  "category" : "concurrency",
  "difficulty" : "beginner",
  "jdkVersion" : "19",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 19+",
  "oldApproach" : "Manual Shutdown",
  "modernApproach" : "try-with-resources",
  "oldCode" : "ExecutorService exec =\n    Executors.newCachedThreadPool();\ntry {\n    exec.submit(task);\n} finally {\n    exec.shutdown();\n    exec.awaitTermination(\n        1, TimeUnit.MINUTES);\n}",
  "modernCode" : "try (var exec =\n        Executors.newCachedThreadPool()) {\n    exec.submit(task);\n}\n// auto shutdown + await on close",
  "summary" : "Use try-with-resources for automatic executor shutdown.",
  "explanation" : "Since Java 19, ExecutorService implements AutoCloseable. The close() method calls shutdown() and waits for tasks to complete. No more manual try/finally shutdown patterns.",
  "whyModernWins" : [ {
    "icon" : "üßπ",
    "title" : "Auto cleanup",
    "desc" : "Shutdown happens automatically when the block exits."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "No leaks",
    "desc" : "Executor always shuts down, even if exceptions occur."
  }, {
    "icon" : "üìñ",
    "title" : "Familiar pattern",
    "desc" : "Same try-with-resources used for files, connections, etc."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 19 (Sept 2022)"
  },
  "docs" : [ {
    "title" : "ExecutorService",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ExecutorService.html"
  } ]
}, {
  "id" : 55,
  "slug" : "lock-free-lazy-init",
  "title" : "Lock-free lazy initialization",
  "category" : "concurrency",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25 (Preview)",
  "oldApproach" : "synchronized + volatile",
  "modernApproach" : "StableValue",
  "oldCode" : "class Config {\n    private static volatile Config inst;\n    static Config get() {\n        if (inst == null) {\n            synchronized (Config.class) {\n                if (inst == null)\n                    inst = load();\n            }\n        }\n        return inst;\n    }\n}",
  "modernCode" : "class Config {\n    private static final\n        StableValue<Config> INST =\n            StableValue.of(Config::load);\n\n    static Config get() {\n        return INST.get();\n    }\n}",
  "summary" : "Replace double-checked locking with StableValue for lazy singletons.",
  "explanation" : "StableValue encapsulates the lazy initialization pattern with correct thread safety. The JVM can optimize the read path after initialization, potentially making it faster than volatile reads.",
  "whyModernWins" : [ {
    "icon" : "üßπ",
    "title" : "No boilerplate",
    "desc" : "No volatile, synchronized, or double-null-check."
  }, {
    "icon" : "‚ö°",
    "title" : "Faster reads",
    "desc" : "JVM can constant-fold after initialization."
  }, {
    "icon" : "‚úÖ",
    "title" : "Provably correct",
    "desc" : "No subtle ordering bugs ‚Äî the JVM handles it."
  } ],
  "support" : {
    "state" : "preview",
    "description" : "Preview in JDK 25 (JEP 502, StableValue). Requires --enable-preview."
  },
  "docs" : [ {
    "title" : "StableValue (JEP 502)",
    "href" : "https://openjdk.org/jeps/502"
  }, {
    "title" : "StableValue",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html"
  } ]
}, {
  "id" : 53,
  "slug" : "process-api",
  "title" : "Modern Process API",
  "category" : "concurrency",
  "difficulty" : "intermediate",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Runtime.exec()",
  "modernApproach" : "ProcessHandle",
  "oldCode" : "Process p = Runtime.getRuntime()\n    .exec(\"ls -la\");\nint code = p.waitFor();\n// no way to get PID\n// no easy process info",
  "modernCode" : "ProcessHandle ph =\n    ProcessHandle.current();\nlong pid = ph.pid();\nph.info().command()\n    .ifPresent(System.out::println);\nph.children().forEach(\n    c -> System.out.println(c.pid()));",
  "summary" : "Inspect and manage OS processes with ProcessHandle.",
  "explanation" : "ProcessHandle provides PIDs, process info (command, arguments, start time, CPU usage), parent/child relationships, and process destruction. No more undocumented Process internals.",
  "whyModernWins" : [ {
    "icon" : "üîç",
    "title" : "Full info",
    "desc" : "Access PID, command, arguments, start time, CPU usage."
  }, {
    "icon" : "üå≥",
    "title" : "Process tree",
    "desc" : "Navigate parent, children, and descendants."
  }, {
    "icon" : "üìä",
    "title" : "Monitoring",
    "desc" : "onExit() returns a CompletableFuture for async monitoring."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "ProcessHandle",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ProcessHandle.html"
  }, {
    "title" : "Process API (JEP 102)",
    "href" : "https://openjdk.org/jeps/102"
  } ]
}, {
  "id" : 48,
  "slug" : "scoped-values",
  "title" : "Scoped values",
  "category" : "concurrency",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25",
  "oldApproach" : "ThreadLocal",
  "modernApproach" : "ScopedValue",
  "oldCode" : "static final ThreadLocal<User> CURRENT =\n    new ThreadLocal<>();\nvoid handle(Request req) {\n    CURRENT.set(authenticate(req));\n    try { process(); }\n    finally { CURRENT.remove(); }\n}",
  "modernCode" : "static final ScopedValue<User> CURRENT =\n    ScopedValue.newInstance();\nvoid handle(Request req) {\n    ScopedValue.where(CURRENT,\n        authenticate(req)\n    ).run(this::process);\n}",
  "summary" : "Share data across call stacks safely without ThreadLocal pitfalls.",
  "explanation" : "ScopedValue provides immutable, inheritable, scope-limited context. Unlike ThreadLocal, scoped values are automatically cleaned up, work with virtual threads, and can't be mutated by callees.",
  "whyModernWins" : [ {
    "icon" : "üîí",
    "title" : "Immutable",
    "desc" : "Callees can read but never modify the scoped value."
  }, {
    "icon" : "üßπ",
    "title" : "Auto cleanup",
    "desc" : "No manual remove() ‚Äî value is scoped to the block."
  }, {
    "icon" : "‚ö°",
    "title" : "Virtual-thread safe",
    "desc" : "Works efficiently with millions of virtual threads."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Finalized in JDK 25 LTS (JEP 506, Sept 2025)."
  },
  "docs" : [ {
    "title" : "Scoped Values (JEP 487)",
    "href" : "https://openjdk.org/jeps/487"
  }, {
    "title" : "ScopedValue",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html"
  } ]
}, {
  "id" : 49,
  "slug" : "stable-values",
  "title" : "Stable values",
  "category" : "concurrency",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25 (Preview)",
  "oldApproach" : "Double-Checked Locking",
  "modernApproach" : "StableValue",
  "oldCode" : "private volatile Logger logger;\nLogger getLogger() {\n    if (logger == null) {\n        synchronized (this) {\n            if (logger == null)\n                logger = createLogger();\n        }\n    }\n    return logger;\n}",
  "modernCode" : "private final StableValue<Logger> logger =\n    StableValue.of(this::createLogger);\n\nLogger getLogger() {\n    return logger.get();\n}",
  "summary" : "Thread-safe lazy initialization without volatile or synchronized.",
  "explanation" : "StableValue provides a lazily initialized, immutable value with built-in thread safety. No double-checked locking, no volatile fields, no synchronized blocks. The JVM can even optimize the read path after initialization.",
  "whyModernWins" : [ {
    "icon" : "üßπ",
    "title" : "Zero boilerplate",
    "desc" : "No volatile, synchronized, or null checks."
  }, {
    "icon" : "‚ö°",
    "title" : "JVM-optimized",
    "desc" : "The JVM can fold the value after initialization."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Guaranteed once",
    "desc" : "The supplier runs exactly once, even under contention."
  } ],
  "support" : {
    "state" : "preview",
    "description" : "Preview in JDK 25 (JEP 502). Requires --enable-preview."
  },
  "docs" : [ {
    "title" : "Stable Values (JEP 502)",
    "href" : "https://openjdk.org/jeps/502"
  }, {
    "title" : "StableValue",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/StableValue.html"
  } ]
}, {
  "id" : 47,
  "slug" : "structured-concurrency",
  "title" : "Structured concurrency",
  "category" : "concurrency",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25 (Preview)",
  "oldApproach" : "Manual Thread Lifecycle",
  "modernApproach" : "StructuredTaskScope",
  "oldCode" : "ExecutorService exec =\n    Executors.newFixedThreadPool(2);\nFuture<User> u = exec.submit(this::fetchUser);\nFuture<Order> o = exec.submit(this::fetchOrder);\ntry {\n    return combine(u.get(), o.get());\n} finally { exec.shutdown(); }",
  "modernCode" : "try (var scope = new StructuredTaskScope\n        .ShutdownOnFailure()) {\n    var u = scope.fork(this::fetchUser);\n    var o = scope.fork(this::fetchOrder);\n    scope.join().throwIfFailed();\n    return combine(u.get(), o.get());\n}",
  "summary" : "Manage concurrent task lifetimes as a single unit of work.",
  "explanation" : "Structured concurrency treats a group of concurrent tasks as one operation. If any subtask fails, the others are cancelled. The scope ensures no thread leaks and gives clear parent-child relationships.",
  "whyModernWins" : [ {
    "icon" : "üõ°Ô∏è",
    "title" : "No thread leaks",
    "desc" : "All forked tasks complete before the scope closes."
  }, {
    "icon" : "‚ö°",
    "title" : "Fast failure",
    "desc" : "ShutdownOnFailure cancels siblings if one fails."
  }, {
    "icon" : "üìê",
    "title" : "Clear structure",
    "desc" : "Task lifetime matches the lexical scope in code."
  } ],
  "support" : {
    "state" : "preview",
    "description" : "Preview in JDK 25 (fifth preview, JEP 505). Requires --enable-preview."
  },
  "docs" : [ {
    "title" : "Structured Concurrency (JEP 499)",
    "href" : "https://openjdk.org/jeps/499"
  }, {
    "title" : "StructuredTaskScope",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html"
  } ]
}, {
  "id" : 52,
  "slug" : "thread-sleep-duration",
  "title" : "Thread.sleep with Duration",
  "category" : "concurrency",
  "difficulty" : "beginner",
  "jdkVersion" : "19",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 19+",
  "oldApproach" : "Milliseconds",
  "modernApproach" : "Duration",
  "oldCode" : "// What unit is 5000? ms? us?\nThread.sleep(5000);\n\n// 2.5 seconds: math required\nThread.sleep(2500);",
  "modernCode" : "Thread.sleep(\n    Duration.ofSeconds(5)\n);\nThread.sleep(\n    Duration.ofMillis(2500)\n);",
  "summary" : "Use Duration for self-documenting time values.",
  "explanation" : "Thread.sleep(Duration) makes the time unit explicit. No more guessing whether 5000 means milliseconds or microseconds. Works with Duration.ofSeconds, ofMillis, ofMinutes, etc.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Self-documenting",
    "desc" : "Duration.ofSeconds(5) is unambiguous."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Unit-safe",
    "desc" : "No accidentally passing microseconds as milliseconds."
  }, {
    "icon" : "üß©",
    "title" : "Composable",
    "desc" : "Duration math: plus(), multipliedBy(), etc."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 19 (Sept 2022)"
  },
  "docs" : [ {
    "title" : "Thread.sleep(Duration)",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Thread.html#sleep(java.time.Duration)"
  } ]
}, {
  "id" : 46,
  "slug" : "virtual-threads",
  "title" : "Virtual threads",
  "category" : "concurrency",
  "difficulty" : "beginner",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Platform Threads",
  "modernApproach" : "Virtual Threads",
  "oldCode" : "Thread thread = new Thread(() -> {\n    System.out.println(\"hello\");\n});\nthread.start();\nthread.join();",
  "modernCode" : "Thread.startVirtualThread(() -> {\n    System.out.println(\"hello\");\n}).join();",
  "summary" : "Create millions of lightweight virtual threads instead of heavy OS threads.",
  "explanation" : "Virtual threads are lightweight threads managed by the JVM, not the OS. You can create millions of them without tuning thread pools. They're ideal for I/O-bound tasks like HTTP calls and database queries.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Lightweight",
    "desc" : "Virtual threads use KB of memory, platform threads use MB."
  }, {
    "icon" : "‚ôæÔ∏è",
    "title" : "Scalable",
    "desc" : "Create millions of threads ‚Äî no pool sizing needed."
  }, {
    "icon" : "üßπ",
    "title" : "Simple model",
    "desc" : "Write blocking code that scales like async code."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Virtual Threads (JEP 444)",
    "href" : "https://openjdk.org/jeps/444"
  }, {
    "title" : "Thread.ofVirtual()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Thread.html#ofVirtual()"
  } ]
}, {
  "id" : 63,
  "slug" : "deserialization-filters",
  "title" : "Deserialization filters",
  "category" : "io",
  "difficulty" : "advanced",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Accept Everything",
  "modernApproach" : "ObjectInputFilter",
  "oldCode" : "// Dangerous: accepts any class\nObjectInputStream ois =\n    new ObjectInputStream(input);\nObject obj = ois.readObject();\n// deserialization attacks possible!",
  "modernCode" : "ObjectInputFilter filter =\n    ObjectInputFilter.Config\n    .createFilter(\n        \"com.myapp.*;!*\"\n    );\nois.setObjectInputFilter(filter);\nObject obj = ois.readObject();",
  "summary" : "Restrict which classes can be deserialized to prevent attacks.",
  "explanation" : "ObjectInputFilter lets you allowlist/denylist classes, limit object graph depth, array sizes, and reference counts. This defends against deserialization vulnerabilities without external libraries.",
  "whyModernWins" : [ {
    "icon" : "üõ°Ô∏è",
    "title" : "Security",
    "desc" : "Prevent deserialization of unexpected/malicious classes."
  }, {
    "icon" : "üìê",
    "title" : "Fine-grained",
    "desc" : "Control depth, array size, references, and class patterns."
  }, {
    "icon" : "üèóÔ∏è",
    "title" : "JVM-wide",
    "desc" : "Set a global filter for all deserialization in the JVM."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "ObjectInputFilter",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/ObjectInputFilter.html"
  }, {
    "title" : "Deserialization Filtering Guide",
    "href" : "https://docs.oracle.com/en/java/javase/25/core/serialization-filtering1.html"
  } ]
}, {
  "id" : 97,
  "slug" : "file-memory-mapping",
  "title" : "File memory mapping",
  "category" : "io",
  "difficulty" : "advanced",
  "jdkVersion" : "22",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 22+",
  "oldApproach" : "MappedByteBuffer",
  "modernApproach" : "MemorySegment with Arena",
  "oldCode" : "try (FileChannel channel =\n    FileChannel.open(path,\n        StandardOpenOption.READ,\n        StandardOpenOption.WRITE)) {\n    MappedByteBuffer buffer =\n        channel.map(\n            FileChannel.MapMode.READ_WRITE,\n            0, (int) channel.size());\n    // Limited to 2GB\n    // Freed by GC, no control\n}",
  "modernCode" : "FileChannel channel =\n    FileChannel.open(path,\n        StandardOpenOption.READ,\n        StandardOpenOption.WRITE);\ntry (Arena arena = Arena.ofShared()) {\n    MemorySegment segment =\n        channel.map(\n            FileChannel.MapMode.READ_WRITE,\n            0, channel.size(), arena);\n    // No size limit\n    // ...\n} // Deterministic cleanup",
  "summary" : "Map files larger than 2GB with deterministic cleanup using MemorySegment.",
  "explanation" : "The Foreign Function & Memory API (JEP 454) introduces MemorySegment for safe and efficient memory access. Unlike MappedByteBuffer, MemorySegment supports files larger than 2GB (Integer.MAX_VALUE), provides deterministic cleanup via Arena, and offers better performance with modern hardware.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "No size limit",
    "desc" : "Map files larger than 2GB without workarounds."
  }, {
    "icon" : "üîí",
    "title" : "Deterministic cleanup",
    "desc" : "Arena ensures memory is freed at scope exit, not GC time."
  }, {
    "icon" : "‚ö°",
    "title" : "Better performance",
    "desc" : "Aligned with modern memory models and hardware."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 22 (March 2024)"
  },
  "docs" : [ ]
}, {
  "id" : 62,
  "slug" : "files-mismatch",
  "title" : "Files.mismatch()",
  "category" : "io",
  "difficulty" : "beginner",
  "jdkVersion" : "12",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 12+",
  "oldApproach" : "Manual Byte Compare",
  "modernApproach" : "Files.mismatch()",
  "oldCode" : "// Compare two files byte by byte\nbyte[] f1 = Files.readAllBytes(path1);\nbyte[] f2 = Files.readAllBytes(path2);\nboolean equal = Arrays.equals(f1, f2);\n// loads both files entirely into memory",
  "modernCode" : "long pos = Files.mismatch(path1, path2);\n// -1 if identical\n// otherwise: position of first difference",
  "summary" : "Compare two files efficiently without loading them into memory.",
  "explanation" : "Files.mismatch() returns the position of the first byte that differs, or -1 if the files are identical. It reads lazily and short-circuits on the first difference.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Memory-efficient",
    "desc" : "Doesn't load entire files into byte arrays."
  }, {
    "icon" : "üéØ",
    "title" : "Pinpoints difference",
    "desc" : "Returns the exact byte position of the first mismatch."
  }, {
    "icon" : "üìè",
    "title" : "One call",
    "desc" : "No manual byte array comparison logic."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 12 (March 2019)"
  },
  "docs" : [ {
    "title" : "Files.mismatch()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/Files.html#mismatch(java.nio.file.Path,java.nio.file.Path)"
  } ]
}, {
  "id" : 56,
  "slug" : "http-client",
  "title" : "Modern HTTP client",
  "category" : "io",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "HttpURLConnection",
  "modernApproach" : "HttpClient",
  "oldCode" : "URL url = new URL(\"https://api.com/data\");\nHttpURLConnection con =\n    (HttpURLConnection) url.openConnection();\ncon.setRequestMethod(\"GET\");\nBufferedReader in = new BufferedReader(\n    new InputStreamReader(con.getInputStream()));\n// read lines, close streams...",
  "modernCode" : "var client = HttpClient.newHttpClient();\nvar request = HttpRequest.newBuilder()\n    .uri(URI.create(\"https://api.com/data\"))\n    .build();\nvar response = client.send(\n    request, BodyHandlers.ofString());\nString body = response.body();",
  "summary" : "Use the built-in HttpClient for clean, modern HTTP requests.",
  "explanation" : "HttpClient supports HTTP/1.1 and HTTP/2, async requests, WebSocket, custom executors, and connection pooling. No more casting URLConnection or manually reading InputStreams.",
  "whyModernWins" : [ {
    "icon" : "üìê",
    "title" : "Builder API",
    "desc" : "Fluent builder for requests, headers, and timeouts."
  }, {
    "icon" : "üîÑ",
    "title" : "HTTP/2 support",
    "desc" : "Built-in HTTP/2 with multiplexing and server push."
  }, {
    "icon" : "‚ö°",
    "title" : "Async ready",
    "desc" : "sendAsync() returns CompletableFuture."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "HttpClient (JEP 321)",
    "href" : "https://openjdk.org/jeps/321"
  }, {
    "title" : "HttpClient",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/HttpClient.html"
  } ]
}, {
  "id" : 59,
  "slug" : "inputstream-transferto",
  "title" : "InputStream.transferTo()",
  "category" : "io",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Manual Copy Loop",
  "modernApproach" : "transferTo()",
  "oldCode" : "byte[] buf = new byte[8192];\nint n;\nwhile ((n = input.read(buf)) != -1) {\n    output.write(buf, 0, n);\n}",
  "modernCode" : "input.transferTo(output);",
  "summary" : "Copy an InputStream to an OutputStream in one call.",
  "explanation" : "transferTo() reads all bytes from the input stream and writes them to the output stream. No buffer management, no loop. It uses an optimized internal buffer.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "One line",
    "desc" : "Replace the entire read/write loop with one method call."
  }, {
    "icon" : "‚ö°",
    "title" : "Optimized",
    "desc" : "Internal buffer size is tuned for performance."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "No bugs",
    "desc" : "No off-by-one errors in buffer management."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "InputStream.transferTo()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/InputStream.html#transferTo(java.io.OutputStream)"
  } ]
}, {
  "id" : 90,
  "slug" : "io-class-console-io",
  "title" : "IO class for console I/O",
  "category" : "io",
  "difficulty" : "beginner",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25+",
  "oldApproach" : "System.out / Scanner",
  "modernApproach" : "IO class",
  "oldCode" : "import java.util.Scanner;\n\nScanner sc = new Scanner(System.in);\nSystem.out.print(\"Name: \");\nString name = sc.nextLine();\nSystem.out.println(\"Hello, \" + name);\nsc.close();",
  "modernCode" : "String name = IO.readln(\"Name: \");\nIO.println(\"Hello, \" + name);",
  "summary" : "The new IO class provides simple, concise methods for console input and output.",
  "explanation" : "Java 25 introduces the IO class (java.io.IO) as part of the implicitly declared classes feature. It provides static methods like println(), print(), readln(), and read() that replace the verbose combination of System.out and Scanner. IO.readln(prompt) handles both prompting and reading in a single call. The class is automatically available in compact source files and can be used in traditional classes via import.",
  "whyModernWins" : [ {
    "icon" : "‚ú®",
    "title" : "Dramatically simpler",
    "desc" : "Two methods replace seven lines of Scanner setup, prompting, reading, and cleanup."
  }, {
    "icon" : "üîí",
    "title" : "No resource leaks",
    "desc" : "No Scanner to close ‚Äî IO methods handle resource management internally."
  }, {
    "icon" : "üéì",
    "title" : "Beginner-friendly",
    "desc" : "New developers can do console I/O without learning Scanner, System.out, or import statements."
  } ],
  "support" : {
    "state" : "preview",
    "description" : "Preview in JDK 25 as part of implicitly declared classes (JEP 495)"
  },
  "docs" : [ {
    "title" : "Simple Source Files (JEP 495)",
    "href" : "https://openjdk.org/jeps/495"
  }, {
    "title" : "IO",
    "href" : "https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/io/IO.html"
  } ]
}, {
  "id" : 60,
  "slug" : "path-of",
  "title" : "Path.of() factory",
  "category" : "io",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "Paths.get()",
  "modernApproach" : "Path.of()",
  "oldCode" : "Path path = Paths.get(\"src\", \"main\",\n    \"java\", \"App.java\");",
  "modernCode" : "Path path = Path.of(\"src\", \"main\",\n    \"java\", \"App.java\");",
  "summary" : "Use Path.of() ‚Äî the modern factory method on the Path interface.",
  "explanation" : "Path.of() is a factory method added directly to the Path interface, replacing the separate Paths utility class. It's more discoverable and consistent with List.of(), Map.of(), etc.",
  "whyModernWins" : [ {
    "icon" : "üìê",
    "title" : "Consistent API",
    "desc" : "Follows the .of() factory pattern like List.of(), Set.of()."
  }, {
    "icon" : "üìñ",
    "title" : "Discoverable",
    "desc" : "Found on the Path type itself, not a separate Paths class."
  }, {
    "icon" : "üßπ",
    "title" : "One less class",
    "desc" : "No need to import the Paths utility class."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "Path.of()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/Path.html#of(java.lang.String,java.lang.String...)"
  } ]
}, {
  "id" : 57,
  "slug" : "reading-files",
  "title" : "Reading files",
  "category" : "io",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "BufferedReader",
  "modernApproach" : "Files.readString()",
  "oldCode" : "StringBuilder sb = new StringBuilder();\ntry (BufferedReader br =\n    new BufferedReader(\n        new FileReader(\"data.txt\"))) {\n    String line;\n    while ((line = br.readLine()) != null)\n        sb.append(line).append(\"\\n\");\n}\nString content = sb.toString();",
  "modernCode" : "String content =\n    Files.readString(Path.of(\"data.txt\"));",
  "summary" : "Read an entire file into a String with one line.",
  "explanation" : "Files.readString() reads a file's entire content into a String. It handles encoding (UTF-8 by default) and resource cleanup. For large files, use Files.lines() for lazy streaming.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "One line",
    "desc" : "Replace 8 lines of BufferedReader boilerplate."
  }, {
    "icon" : "üßπ",
    "title" : "Auto cleanup",
    "desc" : "File handle is closed automatically."
  }, {
    "icon" : "üåê",
    "title" : "UTF-8 default",
    "desc" : "Correct encoding by default ‚Äî no charset confusion."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "Files.readString()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path)"
  }, {
    "title" : "Files.readAllLines()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/Files.html#readAllLines(java.nio.file.Path)"
  } ]
}, {
  "id" : 61,
  "slug" : "try-with-resources-effectively-final",
  "title" : "Try-with-resources improvement",
  "category" : "io",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Re-declare Variable",
  "modernApproach" : "Effectively Final",
  "oldCode" : "Connection conn = getConnection();\n// Must re-declare in try\ntry (Connection c = conn) {\n    use(c);\n}",
  "modernCode" : "Connection conn = getConnection();\n// Use existing variable directly\ntry (conn) {\n    use(conn);\n}",
  "summary" : "Use existing effectively-final variables directly in try-with-resources.",
  "explanation" : "Java 9 allows effectively-final variables to be used directly in try-with-resources without re-declaration. This is cleaner when the resource was created outside the try block.",
  "whyModernWins" : [ {
    "icon" : "üßπ",
    "title" : "No re-declaration",
    "desc" : "Use the existing variable name directly."
  }, {
    "icon" : "üìñ",
    "title" : "Less confusion",
    "desc" : "No separate variable name inside the try block."
  }, {
    "icon" : "üìè",
    "title" : "Concise",
    "desc" : "Fewer lines, same resource safety."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "The try-with-resources Statement",
    "href" : "https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html"
  } ]
}, {
  "id" : 58,
  "slug" : "writing-files",
  "title" : "Writing files",
  "category" : "io",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "FileWriter + BufferedWriter",
  "modernApproach" : "Files.writeString()",
  "oldCode" : "try (FileWriter fw =\n        new FileWriter(\"out.txt\");\n    BufferedWriter bw =\n        new BufferedWriter(fw)) {\n    bw.write(content);\n}",
  "modernCode" : "Files.writeString(\n    Path.of(\"out.txt\"),\n    content\n);",
  "summary" : "Write a String to a file with one line.",
  "explanation" : "Files.writeString() writes content to a file with UTF-8 encoding by default. Options can be passed for appending, creating, etc.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "One line",
    "desc" : "No writer wrapping or try-with-resources needed."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Safe defaults",
    "desc" : "UTF-8 encoding, proper file handle cleanup."
  }, {
    "icon" : "üîß",
    "title" : "Options",
    "desc" : "Pass OpenOption flags for append, create, etc."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "Files.writeString()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/Files.html#writeString(java.nio.file.Path,java.lang.CharSequence,java.nio.file.OpenOption...)"
  } ]
}, {
  "id" : 64,
  "slug" : "helpful-npe",
  "title" : "Helpful NullPointerExceptions",
  "category" : "errors",
  "difficulty" : "beginner",
  "jdkVersion" : "14",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 14+",
  "oldApproach" : "Cryptic NPE",
  "modernApproach" : "Detailed NPE",
  "oldCode" : "// Old NPE message:\n// \"NullPointerException\"\n// at MyApp.main(MyApp.java:42)\n// Which variable was null?!",
  "modernCode" : "// Modern NPE message:\n// Cannot invoke \"String.length()\"\n// because \"user.address().city()\"\n// is null\n// Exact variable identified!",
  "summary" : "JVM automatically tells you exactly which variable was null.",
  "explanation" : "Helpful NPEs describe which expression was null and what operation failed. This is enabled by default since Java 14 ‚Äî no code change needed, just upgrade the JDK.",
  "whyModernWins" : [ {
    "icon" : "üîç",
    "title" : "Exact variable",
    "desc" : "The message names the null variable in the chain."
  }, {
    "icon" : "‚ö°",
    "title" : "Faster debugging",
    "desc" : "No more guessing which of 5 chained calls was null."
  }, {
    "icon" : "üÜì",
    "title" : "Free upgrade",
    "desc" : "No code changes ‚Äî just run on JDK 14+."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 14 (March 2020)"
  },
  "docs" : [ {
    "title" : "Helpful NullPointerExceptions (JEP 358)",
    "href" : "https://openjdk.org/jeps/358"
  } ]
}, {
  "id" : 67,
  "slug" : "multi-catch",
  "title" : "Multi-catch exception handling",
  "category" : "errors",
  "difficulty" : "beginner",
  "jdkVersion" : "7",
  "oldLabel" : "Pre-Java 7",
  "modernLabel" : "Java 7+",
  "oldApproach" : "Separate Catch Blocks",
  "modernApproach" : "Multi-catch",
  "oldCode" : "try {\n    process();\n} catch (IOException e) {\n    log(e);\n} catch (SQLException e) {\n    log(e);\n} catch (ParseException e) {\n    log(e);\n}",
  "modernCode" : "try {\n    process();\n} catch (IOException\n    | SQLException\n    | ParseException e) {\n    log(e);\n}",
  "summary" : "Catch multiple exception types in a single catch block.",
  "explanation" : "Multi-catch handles multiple exception types with the same code. The exception variable is effectively final, so you can rethrow it without wrapping.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "DRY",
    "desc" : "Same handling logic written once instead of three times."
  }, {
    "icon" : "üîÑ",
    "title" : "Rethrowable",
    "desc" : "The caught exception can be rethrown with its precise type."
  }, {
    "icon" : "üìñ",
    "title" : "Scannable",
    "desc" : "All handled types are visible in one place."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 7 (July 2011)"
  },
  "docs" : [ {
    "title" : "The catch Blocks",
    "href" : "https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html"
  } ]
}, {
  "id" : 68,
  "slug" : "null-in-switch",
  "title" : "Null case in switch",
  "category" : "errors",
  "difficulty" : "beginner",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Guard Before Switch",
  "modernApproach" : "case null",
  "oldCode" : "// Must check before switch\nif (status == null) {\n    return \"unknown\";\n}\nreturn switch (status) {\n    case ACTIVE  -> \"active\";\n    case PAUSED  -> \"paused\";\n    default      -> \"other\";\n};",
  "modernCode" : "return switch (status) {\n    case null    -> \"unknown\";\n    case ACTIVE  -> \"active\";\n    case PAUSED  -> \"paused\";\n    default      -> \"other\";\n};",
  "summary" : "Handle null directly as a switch case ‚Äî no separate guard needed.",
  "explanation" : "Pattern matching switch can match null as a case label. This eliminates the need for a null check before the switch and makes null handling explicit and visible.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Explicit",
    "desc" : "null handling is visible right in the switch."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "No NPE",
    "desc" : "Switch on a null value won't throw NullPointerException."
  }, {
    "icon" : "üìê",
    "title" : "All-in-one",
    "desc" : "All cases including null in a single switch expression."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Pattern Matching for switch (JEP 441)",
    "href" : "https://openjdk.org/jeps/441"
  } ]
}, {
  "id" : 65,
  "slug" : "optional-chaining",
  "title" : "Optional chaining",
  "category" : "errors",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Nested Null Checks",
  "modernApproach" : "Optional Pipeline",
  "oldCode" : "String city = null;\nif (user != null) {\n    Address addr = user.getAddress();\n    if (addr != null) {\n        city = addr.getCity();\n    }\n}\nif (city == null) city = \"Unknown\";",
  "modernCode" : "String city = Optional.ofNullable(user)\n    .map(User::address)\n    .map(Address::city)\n    .orElse(\"Unknown\");",
  "summary" : "Replace nested null checks with an Optional pipeline.",
  "explanation" : "Optional.map() chains through nullable values, short-circuiting on the first null. orElse() provides the default. This eliminates pyramid-of-doom null checking.",
  "whyModernWins" : [ {
    "icon" : "üîó",
    "title" : "Chainable",
    "desc" : "Each .map() step handles null transparently."
  }, {
    "icon" : "üìñ",
    "title" : "Linear flow",
    "desc" : "Read left-to-right instead of nested if-blocks."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "NPE-proof",
    "desc" : "null is handled at each step ‚Äî no crash possible."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 8+ (improved in 9+)"
  },
  "docs" : [ {
    "title" : "Optional",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Optional.html"
  } ]
}, {
  "id" : 88,
  "slug" : "optional-orelsethrow",
  "title" : "Optional.orElseThrow() without supplier",
  "category" : "errors",
  "difficulty" : "beginner",
  "jdkVersion" : "10",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 10+",
  "oldApproach" : "get() or orElseThrow(supplier)",
  "modernApproach" : "orElseThrow()",
  "oldCode" : "// Risky: get() throws if empty, no clear intent\nString value = optional.get();\n\n// Verbose: supplier just for NoSuchElementException\nString value = optional\n    .orElseThrow(NoSuchElementException::new);",
  "modernCode" : "// Clear intent: throws NoSuchElementException if empty\nString value = optional.orElseThrow();",
  "summary" : "Use Optional.orElseThrow() as a clearer, intent-revealing alternative to get().",
  "explanation" : "Optional.get() is widely considered a code smell because it hides the possibility of failure. The no-arg orElseThrow(), added in Java 10, does exactly the same thing but makes the intent explicit: the developer expects a value and wants an exception if absent.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Self-documenting",
    "desc" : "orElseThrow() clearly signals that absence is unexpected."
  }, {
    "icon" : "üîí",
    "title" : "Avoids get()",
    "desc" : "Static analysis tools flag get() as risky; orElseThrow() is idiomatic."
  }, {
    "icon" : "‚ö°",
    "title" : "Less boilerplate",
    "desc" : "No need to pass a supplier for the default NoSuchElementException."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 10 (March 2018)."
  },
  "docs" : [ {
    "title" : "Optional.orElseThrow()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Optional.html#orElseThrow()"
  } ]
}, {
  "id" : 69,
  "slug" : "record-based-errors",
  "title" : "Record-based error responses",
  "category" : "errors",
  "difficulty" : "intermediate",
  "jdkVersion" : "16",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 16+",
  "oldApproach" : "Map or Verbose Class",
  "modernApproach" : "Error Records",
  "oldCode" : "// Verbose error class\npublic class ErrorResponse {\n    private final int code;\n    private final String message;\n    // constructor, getters, equals,\n    // hashCode, toString...\n}",
  "modernCode" : "public record ApiError(\n    int code,\n    String message,\n    Instant timestamp\n) {\n    public ApiError(int code, String msg) {\n        this(code, msg, Instant.now());\n    }\n}",
  "summary" : "Use records for concise, immutable error response types.",
  "explanation" : "Records are perfect for error responses ‚Äî they're immutable, have built-in equals/hashCode for comparison, and toString for logging. Custom constructors add validation or defaults.",
  "whyModernWins" : [ {
    "icon" : "üìè",
    "title" : "Concise",
    "desc" : "Define error types in 3 lines instead of 30."
  }, {
    "icon" : "üîí",
    "title" : "Immutable",
    "desc" : "Error data can't be accidentally modified after creation."
  }, {
    "icon" : "üìã",
    "title" : "Auto toString",
    "desc" : "Perfect for logging ‚Äî shows all fields automatically."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 16 (March 2021)"
  },
  "docs" : [ {
    "title" : "Records (JEP 395)",
    "href" : "https://openjdk.org/jeps/395"
  }, {
    "title" : "Record class",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Record.html"
  } ]
}, {
  "id" : 66,
  "slug" : "require-nonnull-else",
  "title" : "Objects.requireNonNullElse()",
  "category" : "errors",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Ternary Null Check",
  "modernApproach" : "requireNonNullElse()",
  "oldCode" : "String name = input != null\n    ? input\n    : \"default\";\n// easy to get the order wrong",
  "modernCode" : "String name = Objects\n    .requireNonNullElse(\n        input, \"default\"\n    );",
  "summary" : "Get a non-null value with a clear default, no ternary needed.",
  "explanation" : "requireNonNullElse returns the first argument if non-null, otherwise the second. The default itself cannot be null ‚Äî it throws NPE if both are null, catching bugs early.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Clear intent",
    "desc" : "Method name describes exactly what it does."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Null-safe default",
    "desc" : "The default value is also checked for null."
  }, {
    "icon" : "üìè",
    "title" : "Readable",
    "desc" : "Better than ternary for simple null-or-default logic."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Objects.requireNonNullElse()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Objects.html#requireNonNullElse(T,T)"
  }, {
    "title" : "Objects.requireNonNullElseGet()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Objects.html#requireNonNullElseGet(T,java.util.function.Supplier)"
  } ]
}, {
  "id" : 72,
  "slug" : "date-formatting",
  "title" : "Date formatting",
  "category" : "datetime",
  "difficulty" : "beginner",
  "jdkVersion" : "8",
  "oldLabel" : "Pre-Java 8",
  "modernLabel" : "Java 8+",
  "oldApproach" : "SimpleDateFormat",
  "modernApproach" : "DateTimeFormatter",
  "oldCode" : "// Not thread-safe!\nSimpleDateFormat sdf =\n    new SimpleDateFormat(\"yyyy-MM-dd\");\nString formatted = sdf.format(date);\n// Must synchronize for concurrent use",
  "modernCode" : "DateTimeFormatter fmt =\n    DateTimeFormatter.ofPattern(\n        \"uuuu-MM-dd\");\nString formatted =\n    LocalDate.now().format(fmt);\n// Thread-safe, immutable",
  "summary" : "Format dates with thread-safe, immutable DateTimeFormatter.",
  "explanation" : "DateTimeFormatter is immutable and thread-safe, unlike SimpleDateFormat. It can be stored as a constant and shared. Predefined formatters like ISO_LOCAL_DATE are available for common formats.",
  "whyModernWins" : [ {
    "icon" : "üõ°Ô∏è",
    "title" : "Thread-safe",
    "desc" : "Share formatters across threads without synchronization."
  }, {
    "icon" : "üìã",
    "title" : "Built-in formats",
    "desc" : "ISO_LOCAL_DATE, ISO_INSTANT, etc. for standard formats."
  }, {
    "icon" : "üîí",
    "title" : "Immutable",
    "desc" : "Store as static final constants safely."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 8 (March 2014)"
  },
  "docs" : [ {
    "title" : "DateTimeFormatter",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/format/DateTimeFormatter.html"
  } ]
}, {
  "id" : 71,
  "slug" : "duration-and-period",
  "title" : "Duration and Period",
  "category" : "datetime",
  "difficulty" : "beginner",
  "jdkVersion" : "8",
  "oldLabel" : "Pre-Java 8",
  "modernLabel" : "Java 8+",
  "oldApproach" : "Millisecond Math",
  "modernApproach" : "Duration / Period",
  "oldCode" : "// How many days between two dates?\nlong diff = date2.getTime()\n    - date1.getTime();\nlong days = diff\n    / (1000 * 60 * 60 * 24);\n// ignores DST, leap seconds",
  "modernCode" : "long days = ChronoUnit.DAYS\n    .between(date1, date2);\nPeriod period = Period.between(\n    date1, date2);\nDuration elapsed = Duration.between(\n    time1, time2);",
  "summary" : "Calculate time differences with type-safe Duration and Period.",
  "explanation" : "Duration is for time-based amounts (hours, minutes, seconds). Period is for date-based amounts (years, months, days). ChronoUnit.between() for simple differences. All handle edge cases correctly.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Type-safe",
    "desc" : "Duration for time, Period for dates ‚Äî no confusion."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Correct math",
    "desc" : "Handles DST transitions, leap years, and leap seconds."
  }, {
    "icon" : "üìñ",
    "title" : "Readable",
    "desc" : "ChronoUnit.DAYS.between() reads like English."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 8 (March 2014)"
  },
  "docs" : [ {
    "title" : "Duration",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/Duration.html"
  }, {
    "title" : "Period",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/Period.html"
  } ]
}, {
  "id" : 75,
  "slug" : "hex-format",
  "title" : "HexFormat",
  "category" : "datetime",
  "difficulty" : "intermediate",
  "jdkVersion" : "17",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 17+",
  "oldApproach" : "Manual Hex Conversion",
  "modernApproach" : "HexFormat",
  "oldCode" : "// Pad to 2 digits, uppercase\nString hex = String.format(\n    \"%02X\", byteValue);\n// Parse hex string\nint val = Integer.parseInt(\n    \"FF\", 16);",
  "modernCode" : "HexFormat hex = HexFormat.of()\n    .withUpperCase();\nString s = hex.toHexDigits(\n    byteValue);\nbyte[] bytes =\n    hex.parseHex(\"48656C6C6F\");",
  "summary" : "Convert between hex strings and byte arrays with HexFormat.",
  "explanation" : "HexFormat provides bidirectional hex encoding/decoding for bytes, ints, and arrays. Configure delimiters, prefix, suffix, and case. No more manual formatting or parsing.",
  "whyModernWins" : [ {
    "icon" : "üìê",
    "title" : "Bidirectional",
    "desc" : "Convert bytes‚Üíhex and hex‚Üíbytes with one API."
  }, {
    "icon" : "üîß",
    "title" : "Configurable",
    "desc" : "Delimiters, prefix, suffix, upper/lower case."
  }, {
    "icon" : "üì¶",
    "title" : "Array support",
    "desc" : "Encode/decode entire byte arrays at once."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 17 LTS (Sept 2021)"
  },
  "docs" : [ {
    "title" : "HexFormat",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/HexFormat.html"
  } ]
}, {
  "id" : 73,
  "slug" : "instant-precision",
  "title" : "Instant with nanosecond precision",
  "category" : "datetime",
  "difficulty" : "intermediate",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Milliseconds",
  "modernApproach" : "Nanoseconds",
  "oldCode" : "// Millisecond precision only\nlong millis =\n    System.currentTimeMillis();\n// 1708012345678",
  "modernCode" : "// Microsecond/nanosecond precision\nInstant now = Instant.now();\n// 2025-02-15T20:12:25.678901234Z\nlong nanos = now.getNano();",
  "summary" : "Get timestamps with microsecond or nanosecond precision.",
  "explanation" : "Java 9 improved the clock resolution so Instant.now() captures microsecond precision on most platforms (nanosecond on some). The old currentTimeMillis() only gives milliseconds.",
  "whyModernWins" : [ {
    "icon" : "üéØ",
    "title" : "Higher precision",
    "desc" : "Microsecond/nanosecond vs millisecond timestamps."
  }, {
    "icon" : "üìê",
    "title" : "Type-safe",
    "desc" : "Instant carries its precision ‚Äî no ambiguous longs."
  }, {
    "icon" : "üåê",
    "title" : "UTC-based",
    "desc" : "Instant is always in UTC ‚Äî no timezone confusion."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "Instant",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/Instant.html"
  }, {
    "title" : "Clock",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/Clock.html"
  } ]
}, {
  "id" : 70,
  "slug" : "java-time-basics",
  "title" : "java.time API basics",
  "category" : "datetime",
  "difficulty" : "beginner",
  "jdkVersion" : "8",
  "oldLabel" : "Pre-Java 8",
  "modernLabel" : "Java 8+",
  "oldApproach" : "Date + Calendar",
  "modernApproach" : "java.time.*",
  "oldCode" : "// Mutable, confusing, zero-indexed months\nCalendar cal = Calendar.getInstance();\ncal.set(2025, 0, 15); // January = 0!\nDate date = cal.getTime();\n// not thread-safe",
  "modernCode" : "LocalDate date = LocalDate.of(\n    2025, Month.JANUARY, 15);\nLocalTime time = LocalTime.of(14, 30);\nInstant now = Instant.now();\n// immutable, thread-safe",
  "summary" : "Use immutable, clear date/time types instead of Date and Calendar.",
  "explanation" : "java.time provides LocalDate, LocalTime, LocalDateTime, Instant, ZonedDateTime ‚Äî all immutable and thread-safe. Months are 1-indexed. No more Calendar.JANUARY = 0 confusion.",
  "whyModernWins" : [ {
    "icon" : "üîí",
    "title" : "Immutable",
    "desc" : "Date/time values can't be accidentally modified."
  }, {
    "icon" : "üìñ",
    "title" : "Clear API",
    "desc" : "Month.JANUARY, not 0. DayOfWeek.MONDAY, not 2."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Thread-safe",
    "desc" : "No synchronization needed ‚Äî share freely across threads."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 8 (March 2014)"
  },
  "docs" : [ {
    "title" : "LocalDate",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/LocalDate.html"
  }, {
    "title" : "LocalTime",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/LocalTime.html"
  }, {
    "title" : "LocalDateTime",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/LocalDateTime.html"
  } ]
}, {
  "id" : 74,
  "slug" : "math-clamp",
  "title" : "Math.clamp()",
  "category" : "datetime",
  "difficulty" : "beginner",
  "jdkVersion" : "21",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 21+",
  "oldApproach" : "Nested min/max",
  "modernApproach" : "Math.clamp()",
  "oldCode" : "// Clamp value between min and max\nint clamped =\n    Math.min(Math.max(value, 0), 100);\n// or: min and max order confusion",
  "modernCode" : "int clamped =\n    Math.clamp(value, 0, 100);\n// value constrained to [0, 100]",
  "summary" : "Clamp a value between bounds with a single clear call.",
  "explanation" : "Math.clamp(value, min, max) constrains a value to the range [min, max]. Clearer than nested Math.min/Math.max and available for int, long, float, and double.",
  "whyModernWins" : [ {
    "icon" : "üìñ",
    "title" : "Self-documenting",
    "desc" : "clamp(value, min, max) is unambiguous."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Less error-prone",
    "desc" : "No more swapping min/max order by accident."
  }, {
    "icon" : "üéØ",
    "title" : "All numeric types",
    "desc" : "Works with int, long, float, and double."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 21 LTS (Sept 2023)"
  },
  "docs" : [ {
    "title" : "Math.clamp()",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#clamp(long,int,int)"
  } ]
}, {
  "id" : 77,
  "slug" : "key-derivation-functions",
  "title" : "Key Derivation Functions",
  "category" : "security",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25",
  "oldApproach" : "Manual PBKDF2",
  "modernApproach" : "KDF API",
  "oldCode" : "SecretKeyFactory factory =\n    SecretKeyFactory.getInstance(\n        \"PBKDF2WithHmacSHA256\");\nKeySpec spec = new PBEKeySpec(\n    password, salt, 10000, 256);\nSecretKey key =\n    factory.generateSecret(spec);",
  "modernCode" : "KDF kdf = KDF.getInstance(\"HKDF-SHA256\");\nSecretKey key = kdf.deriveKey(\n    \"AES\",\n    KDF.HKDFParameterSpec\n        .ofExtract()\n        .addIKM(inputKey)\n        .addSalt(salt)\n        .thenExpand(info, 32)\n        .build()\n);",
  "summary" : "Derive cryptographic keys using the standard KDF API.",
  "explanation" : "The KDF API provides a standard interface for key derivation functions including HKDF. It replaces the awkward SecretKeyFactory + PBEKeySpec pattern with a clean builder API.",
  "whyModernWins" : [ {
    "icon" : "üìê",
    "title" : "Clean API",
    "desc" : "Builder pattern instead of awkward KeySpec constructors."
  }, {
    "icon" : "üîß",
    "title" : "HKDF support",
    "desc" : "Modern HKDF algorithm alongside PBKDF2."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Standard",
    "desc" : "Unified API for all key derivation algorithms."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Finalized in JDK 25 LTS (JEP 510, Sept 2025)."
  },
  "docs" : [ {
    "title" : "Key Derivation Functions (JEP 478)",
    "href" : "https://openjdk.org/jeps/478"
  } ]
}, {
  "id" : 76,
  "slug" : "pem-encoding",
  "title" : "PEM encoding/decoding",
  "category" : "security",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25 (Preview)",
  "oldApproach" : "Manual Base64 + Headers",
  "modernApproach" : "PEM API",
  "oldCode" : "String pem = \"-----BEGIN CERTIFICATE-----\\n\"\n    + Base64.getMimeEncoder()\n        .encodeToString(\n            cert.getEncoded())\n    + \"\\n-----END CERTIFICATE-----\";",
  "modernCode" : "// Encode to PEM\nString pem = PEMEncoder.of()\n    .encodeToString(cert);\n// Decode from PEM\nvar cert = PEMDecoder.of()\n    .decode(pemString);",
  "summary" : "Encode and decode PEM-formatted cryptographic objects natively.",
  "explanation" : "The PEM API provides standard encoding/decoding for certificates, keys, and other cryptographic objects in PEM format. No more manual Base64 wrapping with BEGIN/END headers.",
  "whyModernWins" : [ {
    "icon" : "üßπ",
    "title" : "No manual Base64",
    "desc" : "PEM headers, line wrapping, and Base64 handled automatically."
  }, {
    "icon" : "üîÑ",
    "title" : "Bidirectional",
    "desc" : "Encode to PEM and decode from PEM with one API."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Standard format",
    "desc" : "Produces RFC 7468-compliant PEM output."
  } ],
  "support" : {
    "state" : "preview",
    "description" : "Preview in JDK 25 (JEP 470). Requires --enable-preview."
  },
  "docs" : [ {
    "title" : "PEM Encodings of Certificates (JEP 470)",
    "href" : "https://openjdk.org/jeps/470"
  } ]
}, {
  "id" : 89,
  "slug" : "random-generator",
  "title" : "RandomGenerator interface",
  "category" : "security",
  "difficulty" : "intermediate",
  "jdkVersion" : "17",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 17+",
  "oldApproach" : "new Random() / ThreadLocalRandom",
  "modernApproach" : "RandomGenerator factory",
  "oldCode" : "// Hard-coded to one algorithm\nRandom rng = new Random();\nint value = rng.nextInt(100);\n\n// Or thread-local, but still locked in\nint value = ThreadLocalRandom.current()\n    .nextInt(100);",
  "modernCode" : "// Algorithm-agnostic via factory\nvar rng = RandomGenerator.of(\"L64X128MixRandom\");\nint value = rng.nextInt(100);\n\n// Or get a splittable generator\nvar rng = RandomGeneratorFactory\n    .of(\"L64X128MixRandom\").create();",
  "summary" : "Use the RandomGenerator interface to choose random number algorithms by name without coupling to a specific class.",
  "explanation" : "JDK 17 introduced RandomGenerator as a common interface for all RNG implementations. Instead of hard-coding new Random() or ThreadLocalRandom, you can select algorithms by name via a factory, making it easy to swap between algorithms optimized for different use cases (speed, statistical quality, splittability).",
  "whyModernWins" : [ {
    "icon" : "üîß",
    "title" : "Algorithm-agnostic",
    "desc" : "Choose the best RNG algorithm by name without changing code structure."
  }, {
    "icon" : "‚ö°",
    "title" : "Better algorithms",
    "desc" : "Access to modern LXM generators with superior statistical properties."
  }, {
    "icon" : "üîó",
    "title" : "Unified API",
    "desc" : "One interface covers Random, ThreadLocalRandom, SplittableRandom, and more."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 17 (September 2021, JEP 356)."
  },
  "docs" : [ {
    "title" : "RandomGenerator",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/random/RandomGenerator.html"
  }, {
    "title" : "New Random Generator API (JEP 356)",
    "href" : "https://openjdk.org/jeps/356"
  } ]
}, {
  "id" : 78,
  "slug" : "strong-random",
  "title" : "Strong random generation",
  "category" : "security",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "new SecureRandom()",
  "modernApproach" : "getInstanceStrong()",
  "oldCode" : "// Default algorithm ‚Äî may not be\n// the strongest available\nSecureRandom random =\n    new SecureRandom();\nbyte[] bytes = new byte[32];\nrandom.nextBytes(bytes);",
  "modernCode" : "// Platform's strongest algorithm\nSecureRandom random =\n    SecureRandom.getInstanceStrong();\nbyte[] bytes = new byte[32];\nrandom.nextBytes(bytes);",
  "summary" : "Get the platform's strongest SecureRandom implementation.",
  "explanation" : "getInstanceStrong() returns the SecureRandom implementation configured as the strongest on the platform. This is controlled by the securerandom.strongAlgorithms security property.",
  "whyModernWins" : [ {
    "icon" : "üõ°Ô∏è",
    "title" : "Strongest available",
    "desc" : "Automatically selects the best algorithm for the platform."
  }, {
    "icon" : "üìñ",
    "title" : "Explicit intent",
    "desc" : "Clearly communicates that strong randomness is required."
  }, {
    "icon" : "üîß",
    "title" : "Configurable",
    "desc" : "Administrators can change the strong algorithm via security properties."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "SecureRandom",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/security/SecureRandom.html"
  } ]
}, {
  "id" : 79,
  "slug" : "tls-default",
  "title" : "TLS 1.3 by default",
  "category" : "security",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "Manual TLS Config",
  "modernApproach" : "TLS 1.3 Default",
  "oldCode" : "SSLContext ctx =\n    SSLContext.getInstance(\"TLSv1.2\");\nctx.init(null, trustManagers, null);\nSSLSocketFactory factory =\n    ctx.getSocketFactory();\n// Must specify protocol version",
  "modernCode" : "// TLS 1.3 is the default!\nvar client = HttpClient.newBuilder()\n    .sslContext(SSLContext.getDefault())\n    .build();\n// Already using TLS 1.3",
  "summary" : "TLS 1.3 is enabled by default ‚Äî no explicit protocol configuration needed.",
  "explanation" : "Java 11 added TLS 1.3 support and made it the preferred protocol. The HttpClient uses it automatically. No more manually specifying protocol versions for secure connections.",
  "whyModernWins" : [ {
    "icon" : "üõ°Ô∏è",
    "title" : "More secure",
    "desc" : "TLS 1.3 removes obsolete cipher suites and handshake patterns."
  }, {
    "icon" : "‚ö°",
    "title" : "Faster handshake",
    "desc" : "TLS 1.3 completes in one round trip vs two."
  }, {
    "icon" : "üÜì",
    "title" : "Zero config",
    "desc" : "Secure by default ‚Äî no explicit protocol selection needed."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "SSLContext",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/java.base/javax/net/ssl/SSLContext.html"
  }, {
    "title" : "Java Security Guide",
    "href" : "https://docs.oracle.com/en/java/javase/25/security/java-security-overview1.html"
  } ]
}, {
  "id" : 85,
  "slug" : "aot-class-preloading",
  "title" : "AOT class preloading",
  "category" : "tooling",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25",
  "oldApproach" : "Cold Start Every Time",
  "modernApproach" : "AOT Cache",
  "oldCode" : "// Every startup:\n// - Load 10,000+ classes\n// - Verify bytecode\n// - JIT compile hot paths\n// Startup: 2-5 seconds",
  "modernCode" : "// Training run:\n$ java -XX:AOTCacheOutput=app.aot \\\n    -cp app.jar com.App\n// Production:\n$ java -XX:AOTCache=app.aot \\\n    -cp app.jar com.App",
  "summary" : "Cache class loading and compilation for instant startup.",
  "explanation" : "AOT class preloading caches loaded and linked classes from a training run. On subsequent starts, classes are loaded from the cache, skipping verification and linking. Combined with AOT compilation, this dramatically reduces startup time.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Faster startup",
    "desc" : "Skip class loading, verification, and linking."
  }, {
    "icon" : "üì¶",
    "title" : "Cached state",
    "desc" : "Training run captures the ideal class state."
  }, {
    "icon" : "üîß",
    "title" : "No code changes",
    "desc" : "Works with existing applications ‚Äî just add JVM flags."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available as a standard feature in JDK 25 LTS (JEPs 514/515, Sept 2025)."
  },
  "docs" : [ {
    "title" : "Ahead-of-Time Command-Line Ergonomics (JEP 514)",
    "href" : "https://openjdk.org/jeps/514"
  }, {
    "title" : "AOT Cache (JEP 515)",
    "href" : "https://openjdk.org/jeps/515"
  } ]
}, {
  "id" : 91,
  "slug" : "built-in-http-server",
  "title" : "Built-in HTTP server",
  "category" : "tooling",
  "difficulty" : "beginner",
  "jdkVersion" : "18",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 18+",
  "oldApproach" : "External Server / Framework",
  "modernApproach" : "jwebserver CLI",
  "oldCode" : "// Install and configure a web server\n// (Apache, Nginx, or embedded Jetty)\n\n// Or write boilerplate with com.sun.net.httpserver\nHttpServer server = HttpServer.create(\n    new InetSocketAddress(8080), 0);\nserver.createContext(\"/\", exchange -> { ... });\nserver.start();",
  "modernCode" : "// Terminal: serve current directory\n$ jwebserver\n\n// Or use the API (JDK 18+)\nvar server = SimpleFileServer.createFileServer(\n    new InetSocketAddress(8080),\n    Path.of(\".\"),\n    OutputLevel.VERBOSE);\nserver.start();",
  "summary" : "Java 18 includes a built-in minimal HTTP server for prototyping and file serving.",
  "explanation" : "JDK 18 added a simple, zero-dependency HTTP file server accessible via the jwebserver command-line tool or the SimpleFileServer API. It serves static files from a given directory with no configuration needed. The CLI tool is ideal for quick prototyping, testing, and ad-hoc file sharing ‚Äî no external dependencies or frameworks required. The API allows programmatic use with customizable handlers and output levels.",
  "whyModernWins" : [ {
    "icon" : "üöÄ",
    "title" : "Zero setup",
    "desc" : "Run jwebserver in any directory ‚Äî no installation, config, or dependencies needed."
  }, {
    "icon" : "üì¶",
    "title" : "Built into the JDK",
    "desc" : "Ships with every JDK 18+ installation, always available on any machine with Java."
  }, {
    "icon" : "üß™",
    "title" : "Great for prototyping",
    "desc" : "Serve static files instantly for testing HTML, APIs, or front-end development."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 18 (March 2022)"
  },
  "docs" : [ {
    "title" : "Simple Web Server (JEP 408)",
    "href" : "https://openjdk.org/jeps/408"
  }, {
    "title" : "SimpleFileServer",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/api/jdk.httpserver/com/sun/net/httpserver/SimpleFileServer.html"
  }, {
    "title" : "jwebserver Tool",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/specs/man/jwebserver.html"
  } ]
}, {
  "id" : 84,
  "slug" : "compact-object-headers",
  "title" : "Compact object headers",
  "category" : "tooling",
  "difficulty" : "advanced",
  "jdkVersion" : "25",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 25",
  "oldApproach" : "128-bit Headers",
  "modernApproach" : "64-bit Headers",
  "oldCode" : "// Default: 128-bit object header\n// = 16 bytes overhead per object\n// A boolean field object = 32 bytes!\n// Mark word (64) + Klass pointer (64)",
  "modernCode" : "// -XX:+UseCompactObjectHeaders\n// 64-bit object header\n// = 8 bytes overhead per object\n// 50% less header memory\n// More objects fit in cache",
  "summary" : "Cut object header size in half for better memory density and cache usage.",
  "explanation" : "Compact object headers reduce the per-object overhead from 128 bits to 64 bits on 64-bit platforms. This saves memory and improves cache utilization, especially for applications with many small objects.",
  "whyModernWins" : [ {
    "icon" : "üì¶",
    "title" : "50% smaller headers",
    "desc" : "8 bytes instead of 16 per object."
  }, {
    "icon" : "‚ö°",
    "title" : "Better cache usage",
    "desc" : "More objects fit in CPU cache lines."
  }, {
    "icon" : "üìä",
    "title" : "Higher density",
    "desc" : "Fit more objects in the same heap size."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Finalized in JDK 25 LTS (JEP 519, Sept 2025)."
  },
  "docs" : [ {
    "title" : "Compact Object Headers (JEP 519)",
    "href" : "https://openjdk.org/jeps/519"
  } ]
}, {
  "id" : 83,
  "slug" : "jfr-profiling",
  "title" : "JFR for profiling",
  "category" : "tooling",
  "difficulty" : "intermediate",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "External Profiler",
  "modernApproach" : "Java Flight Recorder",
  "oldCode" : "// Install VisualVM / YourKit / JProfiler\n// Attach to running process\n// Configure sampling\n// Export and analyze\n// External tool required",
  "modernCode" : "// Start with profiling enabled\n$ java -XX:StartFlightRecording=\n    filename=rec.jfr MyApp\n\n// Or attach to running app:\n$ jcmd <pid> JFR.start",
  "summary" : "Profile any Java app with the built-in Flight Recorder ‚Äî no external tools.",
  "explanation" : "Java Flight Recorder (JFR) is a low-overhead profiling tool built into the JVM. It captures events for CPU, memory, GC, I/O, threads, and custom events with minimal performance impact (~1%).",
  "whyModernWins" : [ {
    "icon" : "üÜì",
    "title" : "Built-in",
    "desc" : "No external profiler to install or license."
  }, {
    "icon" : "‚ö°",
    "title" : "Low overhead",
    "desc" : "~1% performance impact ‚Äî safe for production."
  }, {
    "icon" : "üìä",
    "title" : "Rich events",
    "desc" : "CPU, memory, GC, threads, I/O, locks, and custom events."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9/11 (open-sourced in 11)"
  },
  "docs" : [ {
    "title" : "JDK Flight Recorder",
    "href" : "https://docs.oracle.com/en/java/javase/25/docs/specs/man/jfr.html"
  }, {
    "title" : "Flight Recorder API (JEP 328)",
    "href" : "https://openjdk.org/jeps/328"
  } ]
}, {
  "id" : 80,
  "slug" : "jshell-prototyping",
  "title" : "JShell for prototyping",
  "category" : "tooling",
  "difficulty" : "beginner",
  "jdkVersion" : "9",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 9+",
  "oldApproach" : "Create File + Compile + Run",
  "modernApproach" : "jshell REPL",
  "oldCode" : "// 1. Create Test.java\n// 2. javac Test.java\n// 3. java Test\n// Just to test one expression!",
  "modernCode" : "$ jshell\njshell> \"hello\".chars().count()\n$1 ==> 5\njshell> List.of(1,2,3).reversed()\n$2 ==> [3, 2, 1]",
  "summary" : "Try Java expressions interactively without creating files.",
  "explanation" : "JShell is a Read-Eval-Print Loop for Java. Test expressions, experiment with APIs, and prototype code without creating files, compiling, or writing a main method. Tab completion and inline docs included.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "Instant feedback",
    "desc" : "Type an expression, see the result immediately."
  }, {
    "icon" : "üìù",
    "title" : "No files needed",
    "desc" : "No .java files, no compilation step."
  }, {
    "icon" : "üîç",
    "title" : "API exploration",
    "desc" : "Tab completion helps discover methods and parameters."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 9 (Sept 2017)"
  },
  "docs" : [ {
    "title" : "JShell Tool",
    "href" : "https://docs.oracle.com/en/java/javase/25/jshell/introduction-jshell.html"
  }, {
    "title" : "JShell (JEP 222)",
    "href" : "https://openjdk.org/jeps/222"
  } ]
}, {
  "id" : 111,
  "slug" : "junit6-with-jspecify",
  "title" : "JUnit 6 with JSpecify null safety",
  "category" : "tooling",
  "difficulty" : "intermediate",
  "jdkVersion" : "17",
  "oldLabel" : "JUnit 5",
  "modernLabel" : "JUnit 6",
  "oldApproach" : "Unannotated API",
  "modernApproach" : "@NullMarked API",
  "oldCode" : "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass UserServiceTest {\n\n    // JUnit 5: no null contracts on the API\n    // Can assertEquals() accept null? Check source...\n    // Does fail(String) allow null message? Unknown.\n\n    @Test\n    void findUser_found() {\n        // Is result nullable? API doesn't say\n        User result = service.findById(\"u1\");\n        assertNotNull(result);\n        assertEquals(\"Alice\", result.name());\n    }\n\n    @Test\n    void findUser_notFound() {\n        // Hope this returns null, not throws...\n        assertNull(service.findById(\"missing\"));\n    }\n}",
  "modernCode" : "import org.junit.jupiter.api.Test;\nimport org.jspecify.annotations.NullMarked;\nimport org.jspecify.annotations.Nullable;\nimport static org.junit.jupiter.api.Assertions.*;\n\n@NullMarked  // all refs non-null unless @Nullable\nclass UserServiceTest {\n\n    // JUnit 6 API is @NullMarked:\n    // assertNull(@Nullable Object actual)\n    // assertEquals(@Nullable Object, @Nullable Object)\n    // fail(@Nullable String message)\n\n    @Test\n    void findUser_found() {\n        // IDE warns: findById returns @Nullable User\n        @Nullable User result = service.findById(\"u1\");\n        assertNotNull(result); // narrows type to non-null\n        assertEquals(\"Alice\", result.name()); // safe\n    }\n\n    @Test\n    void findUser_notFound() {\n        @Nullable User result = service.findById(\"missing\");\n        assertNull(result); // IDE confirms null expectation\n    }\n}",
  "summary" : "JUnit 6 adopts JSpecify @NullMarked, making null contracts explicit across its assertion API.",
  "explanation" : "JUnit 5 shipped without standardized nullability annotations, leaving developers to guess whether assertion parameters or return values could be null. JUnit 6 adopts JSpecify across its entire module: the @NullMarked annotation makes all unannotated types non-null by default, and @Nullable marks the exceptions. The Assertions class explicitly annotates parameters such as assertNull(@Nullable Object actual) and fail(@Nullable String message), so IDEs and static analyzers like NullAway and Error Prone can catch null misuse at compile time instead of at runtime.",
  "whyModernWins" : [ {
    "icon" : "üìú",
    "title" : "Explicit contracts",
    "desc" : "@NullMarked on the JUnit 6 module documents null semantics directly in the API ‚Äî no source-reading required."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Compile-time safety",
    "desc" : "IDEs and analyzers warn when null is passed where non-null is expected, catching bugs before tests run."
  }, {
    "icon" : "üåê",
    "title" : "Ecosystem standard",
    "desc" : "JSpecify is adopted by Spring, Guava, and others ‚Äî consistent null semantics across your whole stack."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JUnit 6.0 (October 2025, requires Java 17+)"
  },
  "docs" : [ {
    "title" : "JUnit 6 Assertions API",
    "href" : "https://docs.junit.org/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html"
  }, {
    "title" : "JSpecify Nullness User Guide",
    "href" : "https://jspecify.dev/docs/user-guide/"
  }, {
    "title" : "Upgrading to JUnit 6.0",
    "href" : "https://github.com/junit-team/junit-framework/wiki/Upgrading-to-JUnit-6.0/Core-Principles"
  } ]
}, {
  "id" : 82,
  "slug" : "multi-file-source",
  "title" : "Multi-file source launcher",
  "category" : "tooling",
  "difficulty" : "intermediate",
  "jdkVersion" : "22",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 22+",
  "oldApproach" : "Compile All First",
  "modernApproach" : "Source Launcher",
  "oldCode" : "$ javac *.java\n$ java Main\n// Must compile all files first\n// Need a build tool for dependencies",
  "modernCode" : "$ java Main.java\n// Automatically finds and compiles\n// other source files referenced\n// by Main.java",
  "summary" : "Launch multi-file programs without an explicit compile step.",
  "explanation" : "Java 22+ can automatically compile referenced source files when launching from a .java file. This makes small multi-file programs as easy to run as scripts, without needing Maven or Gradle.",
  "whyModernWins" : [ {
    "icon" : "üöÄ",
    "title" : "Zero setup",
    "desc" : "No build tool needed for small multi-file programs."
  }, {
    "icon" : "üîó",
    "title" : "Auto-resolve",
    "desc" : "Referenced classes are found and compiled automatically."
  }, {
    "icon" : "üìù",
    "title" : "Script-like",
    "desc" : "Run multi-file programs like scripts."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since JDK 22 (March 2024)"
  },
  "docs" : [ {
    "title" : "Launch Multi-File Source-Code Programs (JEP 458)",
    "href" : "https://openjdk.org/jeps/458"
  } ]
}, {
  "id" : 81,
  "slug" : "single-file-execution",
  "title" : "Single-file execution",
  "category" : "tooling",
  "difficulty" : "beginner",
  "jdkVersion" : "11",
  "oldLabel" : "Java 8",
  "modernLabel" : "Java 11+",
  "oldApproach" : "Two-Step Compile",
  "modernApproach" : "Direct Launch",
  "oldCode" : "$ javac HelloWorld.java\n$ java HelloWorld\n// Two steps every time",
  "modernCode" : "$ java HelloWorld.java\n// Compiles and runs in one step\n// Also works with shebangs:\n#!/usr/bin/java --source 25",
  "summary" : "Run single-file Java programs directly without javac.",
  "explanation" : "The Java launcher can compile and run a single source file in one command. Combined with shebang support on Unix, Java files can work as scripts. No separate compilation step needed.",
  "whyModernWins" : [ {
    "icon" : "‚ö°",
    "title" : "One command",
    "desc" : "java File.java compiles and runs in one step."
  }, {
    "icon" : "üìù",
    "title" : "Script-like",
    "desc" : "Add a shebang line to make .java files executable scripts."
  }, {
    "icon" : "üéì",
    "title" : "Learning-friendly",
    "desc" : "Newcomers run code immediately without learning build tools."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since JDK 11 (Sept 2018)"
  },
  "docs" : [ {
    "title" : "Launch Single-File Source-Code Programs (JEP 330)",
    "href" : "https://openjdk.org/jeps/330"
  } ]
}, {
  "id" : 102,
  "slug" : "ejb-timer-vs-jakarta-scheduler",
  "title" : "EJB Timer vs Jakarta Scheduler",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 10+",
  "oldApproach" : "EJB TimerService",
  "modernApproach" : "ManagedScheduledExecutorService",
  "oldCode" : "@Stateless\npublic class ReportGenerator {\n    @Resource\n    TimerService timerService;\n\n    @PostConstruct\n    public void init() {\n        timerService.createCalendarTimer(\n            new ScheduleExpression()\n                .hour(\"2\").minute(\"0\"));\n    }\n\n    @Timeout\n    public void generateReport(Timer timer) {\n        // runs every day at 02:00\n        buildDailyReport();\n    }\n}",
  "modernCode" : "@ApplicationScoped\npublic class ReportGenerator {\n    @Resource\n    ManagedScheduledExecutorService scheduler;\n\n    @PostConstruct\n    public void init() {\n        scheduler.scheduleAtFixedRate(\n            this::generateReport,\n            0, 24, TimeUnit.HOURS);\n    }\n\n    public void generateReport() {\n        buildDailyReport();\n    }\n}",
  "summary" : "Replace heavyweight EJB timers with Jakarta Concurrency's ManagedScheduledExecutorService for simpler scheduling.",
  "explanation" : "EJB timers require a @Stateless or @Singleton bean with a @Timeout callback and XML or annotation-based schedule expressions. Jakarta Concurrency provides ManagedScheduledExecutorService, which uses the familiar java.util.concurrent scheduling API. The result is less boilerplate, easier unit testing, and no EJB container dependency.",
  "whyModernWins" : [ {
    "icon" : "ü™∂",
    "title" : "Reduced boilerplate",
    "desc" : "No @Timeout callback or ScheduleExpression ‚Äî use the standard ScheduledExecutorService API."
  }, {
    "icon" : "üß™",
    "title" : "Better testability",
    "desc" : "Plain methods and executor mocks make unit testing straightforward without EJB container."
  }, {
    "icon" : "‚òÅÔ∏è",
    "title" : "Cloud-native friendly",
    "desc" : "Managed executors integrate with container lifecycle and work in lightweight runtimes."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since Jakarta EE 10 / Concurrency 3.0"
  },
  "docs" : [ {
    "title" : "Jakarta Concurrency Specification",
    "href" : "https://jakarta.ee/specifications/concurrency/"
  }, {
    "title" : "Jakarta Concurrency 3.0 API",
    "href" : "https://jakarta.ee/specifications/concurrency/3.0/apidocs/"
  } ]
}, {
  "id" : 99,
  "slug" : "ejb-vs-cdi",
  "title" : "EJB versus CDI",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 8+",
  "oldApproach" : "EJB",
  "modernApproach" : "CDI Bean",
  "oldCode" : "@Stateless\npublic class OrderEJB {\n    @EJB\n    private InventoryEJB inventory;\n\n    public void placeOrder(Order order) {\n        // container-managed transaction\n        inventory.reserve(order.getItem());\n    }\n}",
  "modernCode" : "@ApplicationScoped\npublic class OrderService {\n    @Inject\n    private InventoryService inventory;\n\n    @Transactional\n    public void placeOrder(Order order) {\n        inventory.reserve(order.getItem());\n    }\n}",
  "summary" : "Replace heavyweight EJBs with lightweight CDI beans for dependency injection and transactions.",
  "explanation" : "CDI (Contexts and Dependency Injection) provides the same dependency injection and transaction management as EJBs, but as plain Java classes with no container-specific interfaces or superclasses. Scopes like @ApplicationScoped and @RequestScoped control lifecycle, and @Transactional replaces mandatory EJB transaction semantics.",
  "whyModernWins" : [ {
    "icon" : "ü™∂",
    "title" : "Lightweight",
    "desc" : "CDI beans are plain Java classes with no EJB-specific interfaces or descriptors."
  }, {
    "icon" : "üíâ",
    "title" : "Unified injection",
    "desc" : "@Inject works for every managed bean, JAX-RS resources, and Jakarta EE components alike."
  }, {
    "icon" : "üß™",
    "title" : "Easy unit testing",
    "desc" : "Plain classes without EJB proxy overhead are straightforward to instantiate and mock."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Jakarta EE 8 / Java 11"
  },
  "docs" : [ {
    "title" : "Jakarta CDI Specification",
    "href" : "https://jakarta.ee/specifications/cdi/"
  }, {
    "title" : "Jakarta Transactions ‚Äî @Transactional",
    "href" : "https://jakarta.ee/specifications/transactions/"
  } ]
}, {
  "id" : 109,
  "slug" : "jdbc-resultset-vs-jpa-criteria",
  "title" : "JDBC ResultSet Mapping vs JPA Criteria API",
  "category" : "enterprise",
  "difficulty" : "advanced",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 8+",
  "oldApproach" : "JDBC ResultSet",
  "modernApproach" : "JPA Criteria API",
  "oldCode" : "String sql = \"SELECT * FROM users\"\n    + \" WHERE status = ? AND age > ?\";\ntry (Connection con = ds.getConnection();\n     PreparedStatement ps =\n             con.prepareStatement(sql)) {\n    ps.setString(1, status);\n    ps.setInt(2, minAge);\n    ResultSet rs = ps.executeQuery();\n    List<User> users = new ArrayList<>();\n    while (rs.next()) {\n        User u = new User();\n        u.setId(rs.getLong(\"id\"));\n        u.setName(rs.getString(\"name\"));\n        u.setAge(rs.getInt(\"age\"));\n        users.add(u);\n    }\n}",
  "modernCode" : "@PersistenceContext\nEntityManager em;\n\npublic List<User> findActiveAboveAge(\n        String status, int minAge) {\n    CriteriaBuilder cb = em.getCriteriaBuilder();\n    CriteriaQuery<User> cq =\n        cb.createQuery(User.class);\n    Root<User> root = cq.from(User.class);\n    cq.select(root).where(\n        cb.equal(root.get(\"status\"), status),\n        cb.greaterThan(root.get(\"age\"), minAge));\n    return em.createQuery(cq).getResultList();\n}",
  "summary" : "Replace manual JDBC ResultSet mapping with JPA's type-safe Criteria API for dynamic queries.",
  "explanation" : "Raw JDBC requires building SQL strings, setting parameters by index, and mapping each ResultSet column manually ‚Äî a process that is error-prone and breaks silently when columns change. The JPA Criteria API builds queries programmatically using a type-safe builder pattern. Column names are validated against the entity model, result mapping is automatic, and complex dynamic queries compose cleanly without string concatenation.",
  "whyModernWins" : [ {
    "icon" : "üîí",
    "title" : "Type-safe queries",
    "desc" : "The Criteria builder catches field name and type mismatches at compile time."
  }, {
    "icon" : "üó∫Ô∏è",
    "title" : "Automatic mapping",
    "desc" : "JPA maps result rows to entity objects ‚Äî no manual column-by-column extraction."
  }, {
    "icon" : "üß©",
    "title" : "Composable predicates",
    "desc" : "Dynamic where-clauses build cleanly with and(), or(), and reusable Predicate objects."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Jakarta EE 8 / Java 11"
  },
  "docs" : [ {
    "title" : "Jakarta Persistence Specification",
    "href" : "https://jakarta.ee/specifications/persistence/"
  }, {
    "title" : "Jakarta Persistence 3.1 ‚Äî Criteria API",
    "href" : "https://jakarta.ee/specifications/persistence/3.1/apidocs/"
  } ]
}, {
  "id" : 112,
  "slug" : "jdbc-vs-jooq",
  "title" : "JDBC versus jOOQ",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Raw JDBC",
  "modernLabel" : "jOOQ",
  "oldApproach" : "Raw JDBC",
  "modernApproach" : "jOOQ SQL DSL",
  "oldCode" : "String sql = \"SELECT id, name, email FROM users \"\n           + \"WHERE department = ? AND salary > ?\";\ntry (Connection con = ds.getConnection();\n     PreparedStatement ps =\n             con.prepareStatement(sql)) {\n    ps.setString(1, department);\n    ps.setBigDecimal(2, minSalary);\n    ResultSet rs = ps.executeQuery();\n    List<User> result = new ArrayList<>();\n    while (rs.next()) {\n        result.add(new User(\n            rs.getLong(\"id\"),\n            rs.getString(\"name\"),\n            rs.getString(\"email\")));\n    }\n    return result;\n}",
  "modernCode" : "DSLContext dsl = DSL.using(ds, SQLDialect.POSTGRES);\n\nreturn dsl\n    .select(USERS.ID, USERS.NAME, USERS.EMAIL)\n    .from(USERS)\n    .where(USERS.DEPARTMENT.eq(department)\n        .and(USERS.SALARY.gt(minSalary)))\n    .fetchInto(User.class);",
  "summary" : "Replace raw JDBC string-based SQL with jOOQ's type-safe, fluent SQL DSL.",
  "explanation" : "jOOQ (Java Object Oriented Querying) generates Java code from your database schema, turning table and column names into type-safe Java constants. The fluent DSL mirrors SQL syntax so queries are readable and composable. All parameters are bound automatically, eliminating SQL injection risk. Unlike JPA/JPQL, jOOQ embraces SQL fully ‚Äî window functions, CTEs, RETURNING clauses, and vendor-specific extensions are all first-class.",
  "whyModernWins" : [ {
    "icon" : "üîí",
    "title" : "Type-safe columns",
    "desc" : "Column names are generated Java constants ‚Äî typos and type mismatches become compiler errors instead of runtime failures."
  }, {
    "icon" : "üìñ",
    "title" : "SQL fluency",
    "desc" : "The jOOQ DSL mirrors SQL syntax closely, so complex JOINs, subqueries, and CTEs stay readable."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Injection-free by design",
    "desc" : "Parameters are always bound safely ‚Äî no string concatenation means no SQL injection risk."
  } ],
  "support" : {
    "state" : "available",
    "description" : "jOOQ open-source edition supports all major open-source databases; older commercial databases require a paid license"
  },
  "docs" : [ {
    "title" : "jOOQ ‚Äî Getting Started",
    "href" : "https://www.jooq.org/doc/latest/manual/getting-started/"
  }, {
    "title" : "jOOQ ‚Äî DSL API Reference",
    "href" : "https://www.jooq.org/javadoc/latest/"
  } ]
}, {
  "id" : 100,
  "slug" : "jdbc-vs-jpa",
  "title" : "JDBC versus JPA",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 8+",
  "oldApproach" : "JDBC",
  "modernApproach" : "JPA EntityManager",
  "oldCode" : "String sql = \"SELECT * FROM users WHERE id = ?\";\ntry (Connection con = dataSource.getConnection();\n     PreparedStatement ps =\n             con.prepareStatement(sql)) {\n    ps.setLong(1, id);\n    ResultSet rs = ps.executeQuery();\n    if (rs.next()) {\n        User u = new User();\n        u.setId(rs.getLong(\"id\"));\n        u.setName(rs.getString(\"name\"));\n    }\n}",
  "modernCode" : "@PersistenceContext\nEntityManager em;\n\npublic User findUser(Long id) {\n    return em.find(User.class, id);\n}\n\npublic List<User> findByName(String name) {\n    return em.createQuery(\n        \"SELECT u FROM User u WHERE u.name = :name\",\n        User.class)\n        .setParameter(\"name\", name)\n        .getResultList();\n}",
  "summary" : "Replace verbose JDBC boilerplate with JPA's object-relational mapping and EntityManager.",
  "explanation" : "JPA (Jakarta Persistence API) maps Java objects to database rows, eliminating manual ResultSet processing and SQL string concatenation. EntityManager provides find(), persist(), and JPQL queries so you work with domain objects instead of raw SQL, while the container manages connection pooling and transactions.",
  "whyModernWins" : [ {
    "icon" : "üó∫Ô∏è",
    "title" : "Object mapping",
    "desc" : "Entities are plain annotated classes ‚Äî no manual ResultSet-to-object translation."
  }, {
    "icon" : "üîí",
    "title" : "Type-safe queries",
    "desc" : "JPQL operates on entity types and fields rather than raw table and column strings."
  }, {
    "icon" : "‚ö°",
    "title" : "Built-in caching",
    "desc" : "First- and second-level caches reduce database round-trips automatically."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Jakarta EE 8 / Java 11"
  },
  "docs" : [ {
    "title" : "Jakarta Persistence Specification",
    "href" : "https://jakarta.ee/specifications/persistence/"
  }, {
    "title" : "Jakarta Persistence 3.1 API",
    "href" : "https://jakarta.ee/specifications/persistence/3.1/apidocs/"
  } ]
}, {
  "id" : 103,
  "slug" : "jndi-lookup-vs-cdi-injection",
  "title" : "JNDI Lookup vs CDI Injection",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 8+",
  "oldApproach" : "JNDI Lookup",
  "modernApproach" : "CDI @Inject",
  "oldCode" : "public class OrderService {\n    private DataSource ds;\n\n    public void init() throws NamingException {\n        InitialContext ctx = new InitialContext();\n        ds = (DataSource) ctx.lookup(\n            \"java:comp/env/jdbc/OrderDB\");\n    }\n\n    public List<Order> findAll()\n            throws SQLException {\n        try (Connection con = ds.getConnection()) {\n            // query orders\n        }\n    }\n}",
  "modernCode" : "@ApplicationScoped\npublic class OrderService {\n    @Inject\n    @Resource(name = \"jdbc/OrderDB\")\n    DataSource ds;\n\n    public List<Order> findAll()\n            throws SQLException {\n        try (Connection con = ds.getConnection()) {\n            // query orders\n        }\n    }\n}",
  "summary" : "Replace fragile JNDI string lookups with type-safe CDI injection for container-managed resources.",
  "explanation" : "The traditional JNDI pattern forces you to use string-based resource names, handle NamingException, and manage an InitialContext. CDI injection with @Inject (or @Resource for container resources) lets the container wire dependencies automatically. Typos become compile-time errors, and classes are easier to test because dependencies can be injected directly.",
  "whyModernWins" : [ {
    "icon" : "üîí",
    "title" : "Type-safe wiring",
    "desc" : "Injection errors are caught at deployment time, not at runtime via string lookups."
  }, {
    "icon" : "üóëÔ∏è",
    "title" : "No boilerplate",
    "desc" : "Eliminates InitialContext creation, JNDI name strings, and NamingException handling."
  }, {
    "icon" : "üß™",
    "title" : "Testable",
    "desc" : "Dependencies are injected fields, easily replaced with mocks in unit tests."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Jakarta EE 8 / Java 11"
  },
  "docs" : [ {
    "title" : "Jakarta CDI Specification",
    "href" : "https://jakarta.ee/specifications/cdi/"
  }, {
    "title" : "Jakarta Annotations ‚Äî @Resource",
    "href" : "https://jakarta.ee/specifications/annotations/"
  } ]
}, {
  "id" : 101,
  "slug" : "jpa-vs-jakarta-data",
  "title" : "JPA versus Jakarta Data",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "21",
  "oldLabel" : "Jakarta EE 8+",
  "modernLabel" : "Jakarta EE 11+",
  "oldApproach" : "JPA EntityManager",
  "modernApproach" : "Jakarta Data Repository",
  "oldCode" : "@PersistenceContext\nEntityManager em;\n\npublic User findById(Long id) {\n    return em.find(User.class, id);\n}\n\npublic List<User> findByName(String name) {\n    return em.createQuery(\n        \"SELECT u FROM User u WHERE u.name = :name\",\n        User.class)\n        .setParameter(\"name\", name)\n        .getResultList();\n}\n\npublic void save(User user) {\n    em.persist(user);\n}",
  "modernCode" : "@Repository\npublic interface Users extends CrudRepository<User, Long> {\n    List<User> findByName(String name);\n}",
  "summary" : "Declare a repository interface and let Jakarta Data generate the DAO implementation automatically.",
  "explanation" : "Jakarta Data (Jakarta EE 11) turns data access into a pure interface declaration. You annotate an interface with @Repository and extend a built-in repository type such as CrudRepository. The runtime generates the implementation ‚Äî including derived queries from method names like findByName ‚Äî so there is no EntityManager boilerplate, no JPQL strings, and no hand-written save/find methods.",
  "whyModernWins" : [ {
    "icon" : "ü™Ñ",
    "title" : "Zero boilerplate",
    "desc" : "Declare the interface; the container generates the full DAO implementation at deploy time."
  }, {
    "icon" : "üîç",
    "title" : "Derived queries",
    "desc" : "Method names like findByNameAndStatus are parsed automatically ‚Äî no JPQL or SQL needed."
  }, {
    "icon" : "üîå",
    "title" : "Portable",
    "desc" : "Any Jakarta EE 11 compliant runtime provides the repository implementation with no vendor lock-in."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since Jakarta EE 11 / Java 21 (2024)"
  },
  "docs" : [ {
    "title" : "Jakarta Data 1.0 Specification",
    "href" : "https://jakarta.ee/specifications/data/1.0/"
  }, {
    "title" : "Jakarta Data 1.0 API",
    "href" : "https://jakarta.ee/specifications/data/1.0/apidocs/"
  } ]
}, {
  "id" : 107,
  "slug" : "jsf-managed-bean-vs-cdi-named",
  "title" : "JSF Managed Bean vs CDI Named Bean",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 10+",
  "oldApproach" : "@ManagedBean",
  "modernApproach" : "@Named + CDI",
  "oldCode" : "@ManagedBean\n@SessionScoped\npublic class UserBean implements Serializable {\n    @ManagedProperty(\"#{userService}\")\n    private UserService userService;\n\n    private String name;\n\n    public String getName() { return name; }\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setUserService(UserService svc) {\n        this.userService = svc;\n    }\n}",
  "modernCode" : "@Named\n@SessionScoped\npublic class UserBean implements Serializable {\n    @Inject\n    private UserService userService;\n\n    private String name;\n\n    public String getName() { return name; }\n    public void setName(String name) {\n        this.name = name;\n    }\n}",
  "summary" : "Replace deprecated JSF @ManagedBean with CDI @Named for a unified dependency injection model.",
  "explanation" : "JSF's @ManagedBean and @ManagedProperty were deprecated in Jakarta Faces 2.3 and removed in Jakarta EE 10. The CDI-based replacement uses @Named to expose the bean to EL expressions and @Inject for dependency wiring. This unifies the bean model: JSF pages, JAX-RS resources, and EJBs all share the same CDI container.",
  "whyModernWins" : [ {
    "icon" : "üîó",
    "title" : "Unified model",
    "desc" : "One CDI container manages all beans ‚Äî JSF, REST, and service layers share the same injection."
  }, {
    "icon" : "üóëÔ∏è",
    "title" : "Less boilerplate",
    "desc" : "@Inject replaces @ManagedProperty and its required setter method."
  }, {
    "icon" : "üîÆ",
    "title" : "Future-proof",
    "desc" : "@ManagedBean is removed in Jakarta EE 10; @Named is the supported replacement."
  } ],
  "support" : {
    "state" : "available",
    "description" : "CDI @Named available since Java EE 6; @ManagedBean removed in Jakarta EE 10"
  },
  "docs" : [ {
    "title" : "Jakarta Faces Specification",
    "href" : "https://jakarta.ee/specifications/faces/"
  }, {
    "title" : "Jakarta CDI Specification",
    "href" : "https://jakarta.ee/specifications/cdi/"
  } ]
}, {
  "id" : 104,
  "slug" : "manual-transaction-vs-declarative",
  "title" : "Manual JPA Transaction vs Declarative @Transactional",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 8+",
  "oldApproach" : "Manual Transaction",
  "modernApproach" : "@Transactional",
  "oldCode" : "@PersistenceContext\nEntityManager em;\n\npublic void transferFunds(Long from, Long to,\n                          BigDecimal amount) {\n    EntityTransaction tx = em.getTransaction();\n    tx.begin();\n    try {\n        Account src = em.find(Account.class, from);\n        Account dst = em.find(Account.class, to);\n        src.debit(amount);\n        dst.credit(amount);\n        tx.commit();\n    } catch (Exception e) {\n        tx.rollback();\n        throw e;\n    }\n}",
  "modernCode" : "@ApplicationScoped\npublic class AccountService {\n    @PersistenceContext\n    EntityManager em;\n\n    @Transactional\n    public void transferFunds(Long from, Long to,\n                              BigDecimal amount) {\n        Account src = em.find(Account.class, from);\n        Account dst = em.find(Account.class, to);\n        src.debit(amount);\n        dst.credit(amount);\n    }\n}",
  "summary" : "Replace verbose begin/commit/rollback blocks with a single @Transactional annotation.",
  "explanation" : "Manual transaction management requires explicit begin(), commit(), and rollback() calls wrapped in try-catch blocks ‚Äî every service method repeats this boilerplate. The @Transactional annotation delegates lifecycle management to the container: it begins a transaction before the method, commits on success, and rolls back on RuntimeException automatically.",
  "whyModernWins" : [ {
    "icon" : "üóëÔ∏è",
    "title" : "No boilerplate",
    "desc" : "One annotation replaces repetitive begin/commit/rollback try-catch blocks."
  }, {
    "icon" : "üõ°Ô∏è",
    "title" : "Safer rollback",
    "desc" : "The container guarantees rollback on unchecked exceptions ‚Äî no risk of forgetting the catch block."
  }, {
    "icon" : "üìê",
    "title" : "Declarative control",
    "desc" : "Propagation, isolation, and rollback rules are expressed as annotation attributes."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Jakarta EE 8 / Java 11"
  },
  "docs" : [ {
    "title" : "Jakarta Transactions Specification",
    "href" : "https://jakarta.ee/specifications/transactions/"
  }, {
    "title" : "Jakarta Transactions 2.0 API",
    "href" : "https://jakarta.ee/specifications/transactions/2.0/apidocs/"
  } ]
}, {
  "id" : 106,
  "slug" : "mdb-vs-reactive-messaging",
  "title" : "Message-Driven Bean vs Reactive Messaging",
  "category" : "enterprise",
  "difficulty" : "advanced",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "MicroProfile 4+",
  "oldApproach" : "Message-Driven Bean",
  "modernApproach" : "Reactive Messaging",
  "oldCode" : "@MessageDriven(activationConfig = {\n    @ActivationConfigProperty(\n        propertyName = \"destinationType\",\n        propertyValue = \"jakarta.jms.Queue\"),\n    @ActivationConfigProperty(\n        propertyName = \"destination\",\n        propertyValue = \"java:/jms/OrderQueue\")\n})\npublic class OrderMDB implements MessageListener {\n    @Override\n    public void onMessage(Message message) {\n        TextMessage txt = (TextMessage) message;\n        processOrder(txt.getText());\n    }\n}",
  "modernCode" : "@ApplicationScoped\npublic class OrderProcessor {\n    @Incoming(\"orders\")\n    public void process(Order order) {\n        // automatically deserialized from\n        // the \"orders\" channel\n        fulfillOrder(order);\n    }\n}",
  "summary" : "Replace JMS Message-Driven Beans with MicroProfile Reactive Messaging for simpler event processing.",
  "explanation" : "Message-Driven Beans require implementing MessageListener, configuring activation properties, and manually deserializing JMS messages. MicroProfile Reactive Messaging uses a simple @Incoming annotation on a method that receives typed objects directly. The channel configuration is externalised, making the code broker-agnostic and far easier to test.",
  "whyModernWins" : [ {
    "icon" : "ü™∂",
    "title" : "Minimal code",
    "desc" : "A single @Incoming method replaces the MDB class, MessageListener interface, and activation config."
  }, {
    "icon" : "üîå",
    "title" : "Broker-agnostic",
    "desc" : "Swap Kafka, AMQP, or JMS connectors via configuration without changing application code."
  }, {
    "icon" : "‚òÅÔ∏è",
    "title" : "Cloud-native fit",
    "desc" : "Reactive streams backpressure and lightweight runtime make it ideal for containerised deployments."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since MicroProfile 4.0 / SmallRye Reactive Messaging"
  },
  "docs" : [ {
    "title" : "MicroProfile Reactive Messaging Specification",
    "href" : "https://download.eclipse.org/microprofile/microprofile-reactive-messaging-3.0/microprofile-reactive-messaging-spec-3.0.html"
  }, {
    "title" : "SmallRye Reactive Messaging Documentation",
    "href" : "https://smallrye.io/smallrye-reactive-messaging/"
  } ]
}, {
  "id" : 98,
  "slug" : "servlet-vs-jaxrs",
  "title" : "Servlet versus JAX-RS",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 8+",
  "oldApproach" : "HttpServlet",
  "modernApproach" : "JAX-RS Resource",
  "oldCode" : "@WebServlet(\"/users\")\npublic class UserServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req,\n                         HttpServletResponse res)\n            throws ServletException, IOException {\n        String id = req.getParameter(\"id\");\n        res.setContentType(\"application/json\");\n        res.getWriter().write(\"{\\\"id\\\":\\\"\" + id + \"\\\"}\");\n    }\n}",
  "modernCode" : "@Path(\"/users\")\npublic class UserResource {\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getUser(\n            @QueryParam(\"id\") String id) {\n        return Response.ok(new User(id)).build();\n    }\n}",
  "summary" : "Replace verbose HttpServlet boilerplate with declarative JAX-RS resource classes.",
  "explanation" : "JAX-RS (Jakarta RESTful Web Services) lets you expose REST endpoints using simple annotations like @GET, @Path, and @Produces. No more manual parsing of request parameters or setting content types on the response ‚Äî the runtime handles marshalling and routing automatically.",
  "whyModernWins" : [ {
    "icon" : "üìê",
    "title" : "Declarative routing",
    "desc" : "Annotations define HTTP method, path, and content type instead of imperative if/else dispatch."
  }, {
    "icon" : "üîÑ",
    "title" : "Automatic marshalling",
    "desc" : "Return POJOs directly; the runtime serialises them to JSON or XML based on @Produces."
  }, {
    "icon" : "üß™",
    "title" : "Easier testing",
    "desc" : "Resource classes are plain Java objects, testable without a servlet container."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Jakarta EE 8 / Java 11"
  },
  "docs" : [ {
    "title" : "Jakarta RESTful Web Services Specification",
    "href" : "https://jakarta.ee/specifications/restful-ws/"
  }, {
    "title" : "Jakarta REST 3.1 API",
    "href" : "https://jakarta.ee/specifications/restful-ws/3.1/apidocs/"
  } ]
}, {
  "id" : 108,
  "slug" : "singleton-ejb-vs-cdi-application-scoped",
  "title" : "Singleton EJB vs CDI @ApplicationScoped",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 8+",
  "oldApproach" : "@Singleton EJB",
  "modernApproach" : "@ApplicationScoped CDI",
  "oldCode" : "@Singleton\n@Startup\n@ConcurrencyManagement(\n    ConcurrencyManagementType.CONTAINER)\npublic class ConfigCache {\n    private Map<String, String> cache;\n\n    @PostConstruct\n    public void load() {\n        cache = loadFromDatabase();\n    }\n\n    @Lock(LockType.READ)\n    public String get(String key) {\n        return cache.get(key);\n    }\n\n    @Lock(LockType.WRITE)\n    public void refresh() {\n        cache = loadFromDatabase();\n    }\n}",
  "modernCode" : "@ApplicationScoped\npublic class ConfigCache {\n    private volatile Map<String, String> cache;\n\n    @PostConstruct\n    public void load() {\n        cache = loadFromDatabase();\n    }\n\n    public String get(String key) {\n        return cache.get(key);\n    }\n\n    public void refresh() {\n        cache = loadFromDatabase();\n    }\n}",
  "summary" : "Replace Singleton EJBs with CDI @ApplicationScoped beans for simpler shared-state management.",
  "explanation" : "Singleton EJBs bundle concurrency management (@Lock, @ConcurrencyManagement) and eager initialisation (@Startup) into the EJB container. A CDI @ApplicationScoped bean achieves the same single-instance lifecycle with far less ceremony. When concurrency control is needed, standard java.util.concurrent utilities give you finer-grained control than the EJB lock annotations.",
  "whyModernWins" : [ {
    "icon" : "ü™∂",
    "title" : "Less annotation noise",
    "desc" : "No @ConcurrencyManagement, @Lock, or @Startup ‚Äî just a single @ApplicationScoped annotation."
  }, {
    "icon" : "üîß",
    "title" : "Flexible concurrency",
    "desc" : "Use java.util.concurrent locks or volatile for exactly the thread-safety you need."
  }, {
    "icon" : "üß™",
    "title" : "Easy testing",
    "desc" : "Plain CDI beans can be instantiated directly in tests without an EJB container."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Jakarta EE 8 / Java 11"
  },
  "docs" : [ {
    "title" : "Jakarta CDI Specification",
    "href" : "https://jakarta.ee/specifications/cdi/"
  }, {
    "title" : "Jakarta Enterprise Beans Specification",
    "href" : "https://jakarta.ee/specifications/enterprise-beans/"
  } ]
}, {
  "id" : 105,
  "slug" : "soap-vs-jakarta-rest",
  "title" : "SOAP Web Services vs Jakarta REST",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "11",
  "oldLabel" : "Java EE",
  "modernLabel" : "Jakarta EE 8+",
  "oldApproach" : "JAX-WS / SOAP",
  "modernApproach" : "Jakarta REST / JSON",
  "oldCode" : "@WebService\npublic class UserWebService {\n    @WebMethod\n    public UserResponse getUser(\n            @WebParam(name = \"id\") String id) {\n        User user = findUser(id);\n        UserResponse res = new UserResponse();\n        res.setId(user.getId());\n        res.setName(user.getName());\n        return res;\n    }\n}",
  "modernCode" : "@Path(\"/users\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class UserResource {\n    @Inject\n    UserService userService;\n\n    @GET\n    @Path(\"/{id}\")\n    public User getUser(@PathParam(\"id\") String id) {\n        return userService.findById(id);\n    }\n}",
  "summary" : "Replace heavyweight SOAP/WSDL endpoints with clean Jakarta REST resources returning JSON.",
  "explanation" : "SOAP-based web services rely on WSDL contracts, XML marshalling, and JAX-WS annotations that add significant overhead. Jakarta REST (formerly JAX-RS) uses intuitive annotations like @GET, @Path, and @Produces to expose RESTful JSON APIs. The programming model is simpler, the payloads are smaller, and the approach aligns with how modern microservices communicate.",
  "whyModernWins" : [ {
    "icon" : "ü™∂",
    "title" : "Lighter payloads",
    "desc" : "JSON is more compact than SOAP XML envelopes, reducing bandwidth and parsing overhead."
  }, {
    "icon" : "üìê",
    "title" : "Simple annotations",
    "desc" : "@GET, @Path, and @Produces replace WSDL, @WebService, and @WebMethod ceremony."
  }, {
    "icon" : "üîå",
    "title" : "Microservice-ready",
    "desc" : "REST/JSON is the standard for service-to-service communication in cloud-native architectures."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Jakarta EE 8 / Java 11"
  },
  "docs" : [ {
    "title" : "Jakarta RESTful Web Services Specification",
    "href" : "https://jakarta.ee/specifications/restful-ws/"
  }, {
    "title" : "Jakarta JSON Binding Specification",
    "href" : "https://jakarta.ee/specifications/jsonb/"
  } ]
}, {
  "id" : 110,
  "slug" : "spring-api-versioning",
  "title" : "Spring Framework 7 API Versioning",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "17",
  "oldLabel" : "Spring Boot 2/3",
  "modernLabel" : "Spring Framework 7+",
  "oldApproach" : "Manual URL Path Versioning",
  "modernApproach" : "Native API Versioning",
  "oldCode" : "// Version 1 controller\n@RestController\n@RequestMapping(\"/api/v1/products\")\npublic class ProductControllerV1 {\n    @GetMapping(\"/{id}\")\n    public ProductDtoV1 getProduct(\n            @PathVariable Long id) {\n        return service.getV1(id);\n    }\n}\n\n// Version 2 ‚Äî duplicated structure\n@RestController\n@RequestMapping(\"/api/v2/products\")\npublic class ProductControllerV2 {\n    @GetMapping(\"/{id}\")\n    public ProductDtoV2 getProduct(\n            @PathVariable Long id) {\n        return service.getV2(id);\n    }\n}",
  "modernCode" : "// Configure versioning once\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void configureApiVersioning(\n            ApiVersionConfigurer config) {\n        config.useRequestHeader(\"X-API-Version\");\n    }\n}\n\n// Single controller, version per method\n@RestController\n@RequestMapping(\"/api/products\")\npublic class ProductController {\n    @GetMapping(value = \"/{id}\", version = \"1\")\n    public ProductDtoV1 getV1(@PathVariable Long id) {\n        return service.getV1(id);\n    }\n\n    @GetMapping(value = \"/{id}\", version = \"2\")\n    public ProductDtoV2 getV2(@PathVariable Long id) {\n        return service.getV2(id);\n    }\n}",
  "summary" : "Replace duplicated version-prefixed controllers with Spring Framework 7's native API versioning support.",
  "explanation" : "Before Spring Framework 7, API versioning required separate controller classes per version (e.g., /api/v1/products, /api/v2/products), duplicating request mappings and scattering version logic across many files. Spring Framework 7 introduces native versioning through a new version attribute on @RequestMapping and related annotations, plus a configureApiVersioning hook in WebMvcConfigurer. The version can be resolved from a request header, a URL path segment, or a query parameter ‚Äî all controlled in one place.",
  "whyModernWins" : [ {
    "icon" : "üóÇÔ∏è",
    "title" : "No controller duplication",
    "desc" : "All versions live in one controller class; only the individual handler methods carry a version attribute."
  }, {
    "icon" : "‚öôÔ∏è",
    "title" : "Centralised version strategy",
    "desc" : "Switch from header to URL or query-param versioning in a single configureApiVersioning call."
  }, {
    "icon" : "üìà",
    "title" : "Incremental evolution",
    "desc" : "Add a new version to one method without touching unrelated endpoints or creating new controller files."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since Spring Framework 7.0 (requires Java 17+)"
  },
  "docs" : [ {
    "title" : "Spring Framework 7.0 ‚Äî API Versioning",
    "href" : "https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html#mvc-ann-requestmapping-version"
  }, {
    "title" : "Spring Framework 7.0 Migration Guide",
    "href" : "https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Migration-Guide"
  } ]
}, {
  "id" : 110,
  "slug" : "spring-null-safety-jspecify",
  "title" : "Spring Null Safety with JSpecify",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "17",
  "oldLabel" : "Spring 5/6",
  "modernLabel" : "Spring 7",
  "oldApproach" : "Spring @NonNull/@Nullable",
  "modernApproach" : "JSpecify @NullMarked",
  "oldCode" : "import org.springframework.lang.NonNull;\nimport org.springframework.lang.Nullable;\n\npublic class UserService {\n\n    @Nullable\n    public User findById(@NonNull String id) {\n        return repository.findById(id).orElse(null);\n    }\n\n    @NonNull\n    public List<User> findAll() {\n        return repository.findAll();\n    }\n\n    @NonNull\n    public User save(@NonNull User user) {\n        return repository.save(user);\n    }\n}",
  "modernCode" : "import org.jspecify.annotations.NullMarked;\nimport org.jspecify.annotations.Nullable;\n\n@NullMarked\npublic class UserService {\n\n    public @Nullable User findById(String id) {\n        return repository.findById(id).orElse(null);\n    }\n\n    public List<User> findAll() {\n        return repository.findAll();\n    }\n\n    public User save(User user) {\n        return repository.save(user);\n    }\n}",
  "summary" : "Spring 7 adopts JSpecify annotations, making non-null the default and reducing annotation noise.",
  "explanation" : "Spring 5 and 6 introduced their own null safety annotations in the `org.springframework.lang` package. While useful, these were framework-specific and required annotating every non-null element explicitly. Spring 7 migrates to JSpecify, a cross-ecosystem standard for null safety. The `@NullMarked` annotation at the class or package level declares that all unannotated types are non-null by default. Only actual nullable types need the `@Nullable` annotation, dramatically reducing verbosity. JSpecify annotations are recognized by major static analysis tools such as NullAway, Error Prone, and IntelliJ IDEA, bringing richer tooling support beyond what Spring-specific annotations provided.",
  "whyModernWins" : [ {
    "icon" : "‚úÇÔ∏è",
    "title" : "Non-null by default",
    "desc" : "@NullMarked makes all unannotated types non-null, so only nullable exceptions need annotation."
  }, {
    "icon" : "üåê",
    "title" : "Ecosystem standard",
    "desc" : "JSpecify annotations are a cross-framework standard recognized by NullAway, Error Prone, and IDEs."
  }, {
    "icon" : "üîç",
    "title" : "Richer tooling",
    "desc" : "Modern static analyzers understand JSpecify's null model and report violations at compile time."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Available since Spring Framework 7.0 (requires Java 17+)"
  },
  "docs" : [ {
    "title" : "Spring Framework 7 ‚Äî Null Safety",
    "href" : "https://docs.spring.io/spring-framework/reference/core/null-safety.html"
  }, {
    "title" : "JSpecify Specification",
    "href" : "https://jspecify.dev/docs/spec"
  } ]
}, {
  "id" : 110,
  "slug" : "spring-xml-config-vs-annotations",
  "title" : "Spring XML Bean Config vs Annotation-Driven",
  "category" : "enterprise",
  "difficulty" : "intermediate",
  "jdkVersion" : "17",
  "oldLabel" : "Spring (XML)",
  "modernLabel" : "Spring Boot 3+",
  "oldApproach" : "XML Bean Definitions",
  "modernApproach" : "Annotation-Driven Beans",
  "oldCode" : "<!-- applicationContext.xml -->\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"userRepository\"\n          class=\"com.example.UserRepository\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n\n    <bean id=\"userService\"\n          class=\"com.example.UserService\">\n        <property name=\"repository\" ref=\"userRepository\"/>\n    </bean>\n\n</beans>",
  "modernCode" : "@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\n@Repository\npublic class UserRepository {\n    private final JdbcTemplate jdbc;\n\n    public UserRepository(JdbcTemplate jdbc) {\n        this.jdbc = jdbc;\n    }\n}\n\n@Service\npublic class UserService {\n    private final UserRepository repository;\n\n    public UserService(UserRepository repository) {\n        this.repository = repository;\n    }\n}",
  "summary" : "Replace verbose Spring XML bean definitions with concise annotation-driven configuration in Spring Boot.",
  "explanation" : "Traditional Spring applications wired beans through XML configuration files, declaring each class and its dependencies as verbose <bean> elements. While annotation support existed since Spring 2.5, XML remained the dominant approach until Spring Boot introduced auto-configuration. Spring Boot detects beans annotated with @Component, @Service, @Repository, and @Controller via classpath scanning, satisfies dependencies through constructor injection automatically, and configures infrastructure like DataSource from the classpath ‚Äî eliminating all XML wiring files.",
  "whyModernWins" : [ {
    "icon" : "üö´",
    "title" : "No XML",
    "desc" : "@SpringBootApplication triggers component scanning and auto-configuration, eliminating all XML wiring files."
  }, {
    "icon" : "üíâ",
    "title" : "Constructor injection",
    "desc" : "Spring injects dependencies through constructors automatically, making beans easier to test and reason about."
  }, {
    "icon" : "‚ö°",
    "title" : "Auto-configuration",
    "desc" : "Spring Boot configures DataSource, JPA, and other infrastructure from the classpath with zero boilerplate."
  } ],
  "support" : {
    "state" : "available",
    "description" : "Widely available since Spring Boot 1.0 (April 2014); Spring Boot 3 requires Java 17+"
  },
  "docs" : [ {
    "title" : "Spring Framework ‚Äî Annotation-based Container Configuration",
    "href" : "https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html"
  }, {
    "title" : "Spring Boot ‚Äî Auto-configuration",
    "href" : "https://docs.spring.io/spring-boot/reference/using/auto-configuration.html"
  } ]
} ]
