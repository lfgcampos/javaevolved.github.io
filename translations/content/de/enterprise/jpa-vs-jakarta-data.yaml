title: JPA versus Jakarta Data
oldApproach: JPA EntityManager
modernApproach: Jakarta-Data-Repository
summary: Deklariere ein Repository-Interface und lass Jakarta Data die DAO-Implementierung automatisch generieren.
explanation: Jakarta Data (Jakarta EE 11) wandelt den Datenzugriff in eine reine Interface-Deklaration um. Du annotierst ein Interface mit @Repository und erweiterst einen eingebauten Repository-Typ wie CrudRepository. Die Laufzeitumgebung generiert die Implementierung â€” einschlieÃŸlich abgeleiteter Abfragen aus Methodennamen wie findByName â€” sodass kein EntityManager-Boilerplate, keine JPQL-Strings und keine handgeschriebenen save/find-Methoden nÃ¶tig sind.
whyModernWins:
- icon: ğŸª„
  title: Null Boilerplate
  desc: Deklariere das Interface; der Container generiert die vollstÃ¤ndige DAO-Implementierung zur Deployment-Zeit.
- icon: ğŸ”
  title: Abgeleitete Abfragen
  desc: Methodennamen wie findByNameAndStatus werden automatisch geparst â€” kein JPQL oder SQL nÃ¶tig.
- icon: ğŸ”Œ
  title: Portabel
  desc: Jede Jakarta-EE-11-konforme Laufzeitumgebung stellt die Repository-Implementierung ohne Vendor-Lock-in bereit.
support:
  description: "VerfÃ¼gbar seit Jakarta EE 11 / Java 21 (2024)"
