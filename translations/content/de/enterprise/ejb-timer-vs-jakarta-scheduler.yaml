title: EJB Timer vs. Jakarta Scheduler
oldApproach: EJB TimerService
modernApproach: ManagedScheduledExecutorService
summary: Ersetze schwerfÃ¤llige EJB-Timer durch den ManagedScheduledExecutorService von Jakarta Concurrency fÃ¼r einfachere Aufgabenplanung.
explanation: EJB-Timer benÃ¶tigen einen @Stateless- oder @Singleton-Bean mit einem @Timeout-Callback und XML- oder annotationsbasierten ZeitplanausdrÃ¼cken. Jakarta Concurrency stellt ManagedScheduledExecutorService bereit, der die vertraute java.util.concurrent-Planungs-API verwendet. Das Ergebnis ist weniger Boilerplate, einfachere Unit-Tests und keine EJB-Container-AbhÃ¤ngigkeit.
whyModernWins:
- icon: ğŸª¶
  title: Weniger Boilerplate
  desc: "Kein @Timeout-Callback oder ScheduleExpression â€” verwende die Standard-API von ScheduledExecutorService."
- icon: ğŸ§ª
  title: Bessere Testbarkeit
  desc: Einfache Methoden und Executor-Mocks machen Unit-Tests ohne EJB-Container unkompliziert.
- icon: â˜ï¸
  title: Cloud-native-freundlich
  desc: Verwaltete Executors integrieren sich in den Container-Lebenszyklus und funktionieren in leichtgewichtigen Laufzeiten.
support:
  description: "VerfÃ¼gbar seit Jakarta EE 10 / Concurrency 3.0"
