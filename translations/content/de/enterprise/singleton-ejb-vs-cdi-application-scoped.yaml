title: Singleton EJB vs. CDI @ApplicationScoped
oldApproach: "@Singleton EJB"
modernApproach: "@ApplicationScoped CDI"
summary: Ersetze Singleton-EJBs durch CDI-@ApplicationScoped-Beans fÃ¼r eine einfachere Verwaltung von gemeinsamem Zustand.
explanation: "Singleton-EJBs bÃ¼ndeln Concurrency-Management (@Lock, @ConcurrencyManagement) und frÃ¼hzeitige Initialisierung (@Startup) im EJB-Container. Ein CDI-@ApplicationScoped-Bean erreicht denselben Single-Instance-Lebenszyklus mit wesentlich weniger Aufwand. Wenn Concurrency-Steuerung benÃ¶tigt wird, bieten Standard-java.util.concurrent-Hilfsmittel feinere Kontrolle als die EJB-Lock-Annotationen."
whyModernWins:
- icon: ğŸª¶
  title: Weniger Annotations-Rauschen
  desc: "Kein @ConcurrencyManagement, @Lock oder @Startup â€” nur eine einzige @ApplicationScoped-Annotation."
- icon: ğŸ”§
  title: Flexible NebenlÃ¤ufigkeit
  desc: Verwende java.util.concurrent-Locks oder volatile fÃ¼r genau die benÃ¶tigte Thread-Sicherheit.
- icon: ğŸ§ª
  title: Einfaches Testen
  desc: Einfache CDI-Beans kÃ¶nnen in Tests direkt ohne EJB-Container instanziiert werden.
support:
  description: Weitgehend verfÃ¼gbar seit Jakarta EE 8 / Java 11
