title: EJB Timer vs Jakarta Scheduler
oldApproach: EJB TimerService
modernApproach: ManagedScheduledExecutorService
summary: ZastÄ…p ciÄ™Å¼kie timery EJB prostszym harmonogramowaniem przez ManagedScheduledExecutorService z Jakarta Concurrency.
explanation: Timery EJB wymagajÄ… beana @Stateless lub @Singleton, callbacku @Timeout i wyraÅ¼eÅ„ harmonogramu w adnotacjach albo XML. Jakarta Concurrency udostÄ™pnia ManagedScheduledExecutorService z dobrze znanym API java.util.concurrent. To mniej boilerplate, Å‚atwiejsze testy jednostkowe i brak zaleÅ¼noÅ›ci od kontenera EJB.
whyModernWins:
  - icon: ğŸª¶
    title: Mniej boilerplate
    desc: Bez callbacku @Timeout i ScheduleExpression, uÅ¼ywasz standardowego API ScheduledExecutorService.
  - icon: ğŸ§ª
    title: Lepsza testowalnoÅ›Ä‡
    desc: ZwykÅ‚e metody i mocki executora upraszczajÄ… testy bez kontenera EJB.
  - icon: â˜ï¸
    title: PodejÅ›cie cloud-native
    desc: Managed executory integrujÄ… siÄ™ z cyklem Å¼ycia kontenera i dziaÅ‚ajÄ… w lekkich runtime'ach.
support:
  description: DostÄ™pne od Jakarta EE 10 / Concurrency 3.0
